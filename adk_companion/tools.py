"""
ADK Companion - 工具集
"""

import os
import json
from pathlib import Path
from typing import Optional
from github import Github
from dotenv import load_dotenv
load_dotenv()

def find_adk_site_packages() -> Optional[Path]:
    """查找当前 Python 环境下 ADK 库的 site-packages 路径"""
    try:
        import google.adk
        adk_path = Path(google.adk.__file__).parent
        return adk_path
    except ImportError:
        return None

def read_adk_codebase(keyword: str, max_results: int = 10) -> list[str]:
    """在 ADK 源码中搜索关键词并返回匹配的文件内容片段"""
    adk_path = find_adk_site_packages()
    if not adk_path:
        return ["ADK 未安装在当前环境中"]
    
    results = []
    try:
        # 简单实现：遍历 .py 文件并搜索关键词
        for py_file in adk_path.rglob("*.py"):
            if len(results) >= max_results:
                break
            try:
                content = py_file.read_text(encoding="utf-8")
                if keyword.lower() in content.lower():
                    results.append(f"文件: {py_file.relative_to(adk_path)}\n{content[:500]}...")
            except Exception:
                continue
    except Exception as e:
        results.append(f"搜索出错: {e}")
    
    return results[:max_results]

def check_upstream_release() -> dict:
    """检查上游 ADK 仓库的最新发布版本"""
    try:
        # 使用 GitHub API 获取最新发布
        token = os.getenv("GITHUB_TOKEN")
        g = Github(token) if token else Github()
        repo = g.get_repo("google/adk-python")
        latest_release = repo.get_latest_release()
        
        return {
            "tag_name": latest_release.tag_name,
            "published_at": latest_release.published_at.isoformat(),
            "body": latest_release.body[:1000] + "..." if len(latest_release.body) > 1000 else latest_release.body
        }
    except Exception as e:
        return {"error": str(e)}

def generate_pr(
    title: str,
    description: str,
    files_to_modify: dict = None,
    files_to_create: dict = None,
    base_branch: str = "main",
    branch_prefix: str = "feature",
    target_repo: str = None
) -> dict:
    """
    通用 PR 生成器 - 直接对远程仓库创建 PR
    
    Args:
        title: PR 标题
        description: PR 描述
        files_to_modify: 要修改的文件字典 {文件路径: 新内容}
        files_to_create: 要创建的文件字典 {文件路径: 文件内容}
        base_branch: 目标分支（默认 main）
        branch_prefix: 分支前缀（默认 feature）
        target_repo: 目标仓库，格式为 "owner/repo"，如果不指定则尝试从环境获取
    
    Returns:
        dict: 包含 PR 信息或错误信息
    """
    try:
        from datetime import datetime
        
        # 检查 GitHub Token
        token = os.getenv("GITHUB_TOKEN")
        if not token:
            return {"error": "需要设置 GITHUB_TOKEN 环境变量"}
        
        # 确定目标仓库
        if not target_repo:
            return {"error": "需要指定 target_repo 参数，格式为 'owner/repo'"}
        
        # 验证仓库格式
        if '/' not in target_repo or len(target_repo.split('/')) != 2:
            return {"error": "target_repo 格式错误，应为 'owner/repo'"}
        
        g = Github(token)
        
        # 验证仓库存在且可访问
        try:
            github_repo = g.get_repo(target_repo)
        except Exception as e:
            return {"error": f"无法访问仓库 {target_repo}: {str(e)}"}
        
        # 如果没有文件操作，直接创建一个空的 PR
        if not files_to_modify and not files_to_create:
            try:
                # 创建一个简单的 PR（不涉及文件更改）
                pr = github_repo.create_pull(
                    title=title,
                    body=f"{description}\n\n---\nGenerated by ADK Companion at {datetime.now().isoformat()}",
                    head=base_branch,  # 使用同一分支作为源和目标
                    base=base_branch
                )
                return {
                    "status": "success",
                    "pr_url": pr.html_url,
                    "pr_number": pr.number,
                    "message": f"Created PR #{pr.number}: {title}"
                }
            except Exception as e:
                return {"error": f"创建 PR 失败: {str(e)}"}
        
        # 有文件操作时，需要通过 GitHub API 直接创建文件
        try:
            # 生成分支名
            safe_title = "".join(c for c in title if c.isalnum() or c in (' ', '-', '_')).rstrip()
            if not safe_title:
                safe_title = "update"
            branch_name = f"{branch_prefix}/{ '-'.join(safe_title.lower().split()[:5])}"
            
            # 获取基础分支的最新提交
            base_branch_ref = github_repo.get_branch(base_branch)
            base_sha = base_branch_ref.commit.sha
            
            # 创建新分支
            try:
                github_repo.create_git_ref(
                    ref=f"refs/heads/{branch_name}",
                    sha=base_sha
                )
            except Exception as e:
                if "already exists" in str(e):
                    # 分支已存在，删除后重新创建
                    try:
                        github_repo.get_git_ref(f"heads/{branch_name}").delete()
                        github_repo.create_git_ref(
                            ref=f"refs/heads/{branch_name}",
                            sha=base_sha
                        )
                    except Exception as delete_e:
                        return {"error": f"无法创建分支 {branch_name}: {str(delete_e)}"}
                else:
                    return {"error": f"无法创建分支 {branch_name}: {str(e)}"}
            
            # 更新或创建文件
            all_files_changed = []
            
            # 处理要修改的文件
            if files_to_modify:
                for file_path, new_content in files_to_modify.items():
                    try:
                        # 获取当前文件内容（如果存在）
                        try:
                            current_file = github_repo.get_contents(file_path, ref=base_branch)
                            github_repo.update_file(
                                path=file_path,
                                message=f"Update {file_path}",
                                content=new_content,
                                sha=current_file.sha,
                                branch=branch_name
                            )
                        except Exception:
                            # 文件不存在，创建新文件
                            github_repo.create_file(
                                path=file_path,
                                message=f"Create {file_path}",
                                content=new_content,
                                branch=branch_name
                            )
                        all_files_changed.append(file_path)
                    except Exception as e:
                        return {"error": f"处理文件 {file_path} 失败: {str(e)}"}
            
            # 处理要创建的文件
            if files_to_create:
                for file_path, content in files_to_create.items():
                    try:
                        github_repo.create_file(
                            path=file_path,
                            message=f"Add {file_path}",
                            content=content,
                            branch=branch_name
                        )
                        all_files_changed.append(file_path)
                    except Exception as e:
                        return {"error": f"创建文件 {file_path} 失败: {str(e)}"}
            
            # 创建 PR
            commit_message = f"""{title}\n\n{description}\n\n---\nGenerated by ADK Companion at {datetime.now().isoformat()}\nFiles changed: {', '.join(all_files_changed)}"""
            
            pr = github_repo.create_pull(
                title=title,
                body=commit_message,
                head=branch_name,
                base=base_branch
            )
            
            return {
                "status": "success",
                "pr_url": pr.html_url,
                "pr_number": pr.number,
                "branch_name": branch_name,
                "files_changed": all_files_changed,
                "message": f"Created PR #{pr.number}: {title}"
            }
            
        except Exception as e:
            return {"error": f"通过 GitHub API 操作失败: {str(e)}"}
    except Exception as e:
        return {"error": f"生成 PR 时出错: {str(e)}"}

def read_github_repo(
    file_path: str = None,
    branch: str = "main",
    max_files: int = 50,
    target_repo: str = "fgh23333/adk-companion"
) -> dict:
    """
    读取 GitHub 仓库的项目结构或指定文件内容
    
    Args:
        file_path: 指定文件路径（相对于仓库根目录），如果为空则返回目录结构
        branch: 分支名，默认为 main
        max_files: 最大文件数量限制（仅在读取目录结构时生效）
        target_repo: 目标仓库，格式为 "owner/repo" (默认 "fgh23333/adk-companion")
    
    Returns:
        dict: 包含文件结构或文件内容的字典
    """
    try:
        token = os.getenv("GITHUB_TOKEN")
        g = Github(token) if token else Github()
        
        # 获取仓库对象
        repo = g.get_repo(target_repo)
        
        if file_path:
            # 读取指定文件内容
            try:
                file_content = repo.get_contents(file_path, ref=branch)
                if file_content.type == "file":
                    return {
                        "file_path": file_path,
                        "content": file_content.decoded_content.decode('utf-8'),
                        "size": file_content.size,
                        "sha": file_content.sha
                    }
                else:
                    return {"error": f"'{file_path}' 是一个目录，不是文件"}
            except Exception as e:
                return {"error": f"读取文件 '{file_path}' 失败: {str(e)}"}
        else:
            # 获取目录结构
            try:
                file_tree = []
                contents = repo.get_contents("", ref=branch)
                
                def process_directory(contents, prefix="", depth=0):
                    if depth > 3 or len(file_tree) >= max_files:  # 限制深度和数量
                        return
                    
                    for content in contents:
                        if len(file_tree) >= max_files:
                            break
                            
                        if content.type == "dir":
                            file_tree.append({
                                "type": "dir",
                                "path": f"{prefix}{content.name}/",
                                "size": 0
                            })
                            
                            # 递归获取子目录内容（限制深度）
                            if depth < 2:
                                try:
                                    sub_contents = repo.get_contents(content.path, ref=branch)
                                    process_directory(sub_contents, f"{prefix}{content.name}/", depth + 1)
                                except:
                                    continue
                        else:
                            file_tree.append({
                                "type": "file",
                                "path": f"{prefix}{content.name}",
                                "size": content.size,
                                "sha": content.sha
                            })
                
                process_directory(contents)
                
                return {
                    "repo": target_repo,
                    "branch": branch,
                    "total_files": len([f for f in file_tree if f["type"] == "file"]),
                    "total_dirs": len([f for f in file_tree if f["type"] == "dir"]),
                    "file_tree": file_tree[:max_files]
                }
                
            except Exception as e:
                return {"error": f"获取目录结构失败: {str(e)}"}
                
    except Exception as e:
        return {"error": f"GitHub API 调用失败: {str(e)}"}

def generate_evolution_pr(target_version: str, sample_code: str, dependency_changes: str, target_repo: str = None) -> dict:
    """
    生成 ADK 升级 PR - 使用通用 PR 生成器的特化版本
    
    Args:
        target_version: 目标版本号
        sample_code: 示例代码内容
        dependency_changes: 依赖变更说明
        target_repo: 目标仓库，格式为 "owner/repo"
    """
    from datetime import datetime
    
    title = f"feat: upgrade to ADK {target_version}"
    description = f"""Upgrade google-adk to version {target_version}\n\nChanges:\n- Update google-adk to version {target_version}\n- Add new feature sample: new_feature_{target_version}.py\n\n{dependency_changes}"""
    
    # 修改 requirements.txt
    files_to_modify = {}
    requirements_path = "requirements.txt"
    if (Path(__file__).parent.parent.parent / requirements_path).exists():
        with open(Path(__file__).parent.parent.parent / requirements_path, 'r', encoding='utf-8') as f:
            content = f.read()
        
        lines = content.split('\n')
        updated_lines = []
        for line in lines:
            if line.startswith('google-adk'):
                updated_lines.append(f'google-adk=={target_version}')
            else:
                updated_lines.append(line)
        
        files_to_modify[requirements_path] = '\n'.join(updated_lines)
    
    # 创建示例文件
    files_to_create = {
        f"samples/new_feature_{target_version}.py": f'''"""\n新功能示例 - 版本 {target_version}\n生成时间: {datetime.now().isoformat()}\n"""\n\n{sample_code}\n\nif __name__ == "__main__":\n    # 示例用法\n    print("新功能示例运行完成")\n'''
    }
    
    return generate_pr(
        title=title,
        description=description,
        files_to_modify=files_to_modify,
        files_to_create=files_to_create,
        branch_prefix="chore",
        target_repo=target_repo
    )

def review_pr(
    repo_path: str,
    pr_number: int,
    approve: bool = False,
    review_comment: str = None,
    token_env: str = "GITHUB_TOKEN"
) -> dict:
    """
    审查 PR 并可选择批准或添加评论
    
    Args:
        repo_path: 仓库路径，格式为 "owner/repo"
        pr_number: PR 编号
        approve: 是否批准 PR（默认 False）
        review_comment: 审查评论（可选）
        token_env: GitHub Token 环境变量名（默认 "GITHUB_TOKEN"）
    
    Returns:
        dict: 包含审查结果或错误信息
    """
    try:
        token = os.getenv(token_env)
        if not token:
            return {"error": f"需要设置 {token_env} 环境变量"}
        
        g = Github(token)
        repo = g.get_repo(repo_path)
        pr = repo.get_pull(pr_number)
        
        # 检查是否是自己的PR
        current_user = g.get_user()
        is_own_pr = pr.user.login == current_user.login
        
        if is_own_pr and approve:
            return {
                "error": "无法批准自己的PR",
                "pr_author": pr.user.login,
                "current_user": current_user.login,
                "token_used": token_env,
                "suggestion": "您可以：1) 使用 request_pr_review 请求其他用户审查，2) 只添加评论而不批准",
                "can_comment": True
            }
        
        # 获取 PR 文件变更
        files_changed = []
        for file in pr.get_files():
            files_changed.append({
                "filename": file.filename,
                "status": file.status,
                "additions": file.additions,
                "deletions": file.deletions,
                "changes": file.changes,
                "patch": file.patch[:1000] + "..." if len(file.patch) > 1000 else file.patch
            })
        
        # 获取 PR 详情
        pr_details = {
            "number": pr.number,
            "title": pr.title,
            "body": pr.body,
            "state": pr.state,
            "head_branch": pr.head.ref,
            "base_branch": pr.base.ref,
            "author": pr.user.login,
            "created_at": pr.created_at.isoformat(),
            "updated_at": pr.updated_at.isoformat(),
            "mergeable": pr.mergeable,
            "mergeable_state": pr.mergeable_state,
            "files_changed": files_changed,
            "commits": pr.commits,
            "additions": pr.additions,
            "deletions": pr.deletions,
            "changed_files": pr.changed_files
        }
        
        # 如果需要批准或添加评论
        if approve or review_comment:
            try:
                # 创建审查
                if approve:
                    pr.create_review(
                        body=review_comment or "LGTM! Approved by ADK Companion.",
                        event="APPROVE"
                    )
                    pr_details["review_action"] = "approved"
                elif review_comment:
                    pr.create_review(
                        body=review_comment,
                        event="COMMENT"
                    )
                    pr_details["review_action"] = "commented"
                    
            except Exception as e:
                return {"error": f"创建审查失败: {str(e)}"}
        
        return {
            "status": "success",
            "pr_details": pr_details,
            "token_used": token_env,
            "message": f"Successfully reviewed PR #{pr_number}"
        }
        
    except Exception as e:
        return {"error": f"审查 PR 失败: {str(e)}"}

def merge_pr(
    repo_path: str,
    pr_number: int,
    merge_method: str = "merge",
    commit_title: str = None,
    commit_message: str = None,
    token_env: str = "GITHUB_TOKEN"
) -> dict:
    """
    合并 PR
    
    Args:
        repo_path: 仓库路径，格式为 "owner/repo"
        pr_number: PR 编号
        merge_method: 合并方法，可选 "merge", "squash", "rebase"（默认 "merge"）
        commit_title: 合并提交标题（可选）
        commit_message: 合并提交消息（可选）
        token_env: GitHub Token 环境变量名（默认 "GITHUB_TOKEN"）
    
    Returns:
        dict: 包含合并结果或错误信息
    """
    try:
        token = os.getenv(token_env)
        if not token:
            return {"error": f"需要设置 {token_env} 环境变量"}
        
        g = Github(token)
        repo = g.get_repo(repo_path)
        pr = repo.get_pull(pr_number)
        
        # 检查 PR 是否可合并
        if not pr.mergeable:
            return {
                "error": "PR 不可合并",
                "mergeable_state": pr.mergeable_state,
                "status": pr.raw_data.get('status', 'unknown')
            }
        
        # 检查是否有合并冲突
        if pr.mergeable_state == "dirty":
            return {"error": "PR 有合并冲突，无法自动合并"}
        
        # 检查是否需要 CI 通过
        if pr.mergeable_state == "blocked":
            # 获取状态检查
            status_checks = []
            try:
                for commit in pr.get_commits():
                    for status in commit.get_status().statuses:
                        status_checks.append({
                            "context": status.context,
                            "state": status.state,
                            "description": status.description,
                            "target_url": status.target_url
                        })
            except Exception:
                pass
            
            return {
                "error": "PR 被阻止合并，可能需要 CI 检查通过或审查批准",
                "status_checks": status_checks
            }
        
        # 执行合并
        try:
            merge_result = pr.merge(
                commit_message=commit_message,
                commit_title=commit_title,
                merge_method=merge_method
            )
            
            return {
                "status": "success",
                "merged": merge_result.merged,
                "sha": merge_result.sha,
                "message": merge_result.message,
                "pr_number": pr_number,
                "merge_method": merge_method,
                "merged_at": merge_result.merged_at.isoformat() if hasattr(merge_result, "merged_at") and merge_result.merged_at else None,
                "token_used": token_env
            }
            
        except Exception as e:
            
            # 尝试获取更详细的错误信息
            error_msg = None
            try:
                error_msg = str(e)
            except Exception as str_err:
                error_msg = f"异常无法转换为字符串 (类型: {type(e).__name__})"
            
            # 提供更详细的错误信息
            if error_msg and "Required status check" in error_msg:
                return {"error": "合并失败：必需的状态检查未通过"}
            elif error_msg and "Review required" in error_msg:
                return {"error": "合并失败：需要代码审查"}
            elif error_msg and "not authorized" in error_msg.lower():
                return {"error": "合并失败：没有权限合并此 PR"}
            elif error_msg and "merge conflict" in error_msg.lower():
                return {"error": "合并失败：存在合并冲突"}
            else:
                detailed_error = f"合并失败: {error_msg if error_msg else '未知错误'} (类型: {type(e).__name__})"
                return {"error": detailed_error}
        
    except Exception as e:
        
        # 尝试安全地获取错误信息
        error_msg = "未知外层异常"
        try:
            error_msg = str(e)
        except Exception:
            error_msg = f"外层异常无法转换为字符串 (类型: {type(e).__name__})"
        
        return {"error": f"合并 PR 失败: {error_msg}"}

def check_pr_author(repo_path: str, pr_number: int, token_env: str = "GITHUB_TOKEN") -> dict:
    """
    检查 PR 的创建者信息
    
    Args:
        repo_path: 仓库路径，格式为 "owner/repo"
        pr_number: PR 编号
        token_env: GitHub Token 环境变量名（默认 "GITHUB_TOKEN"）
    
    Returns:
        dict: 包含 PR 作者信息和当前用户信息
    """
    try:
        # 参数验证
        if not repo_path or not isinstance(repo_path, str):
            return {"error": "repo_path 必须是有效的字符串，格式为 'owner/repo'"}
        
        if not pr_number or not isinstance(pr_number, int):
            return {"error": "pr_number 必须是有效的整数"}
        
        if not token_env or not isinstance(token_env, str):
            return {"error": "token_env 必须是有效的字符串"}
        
        token = os.getenv(token_env)
        if not token:
            return {"error": f"需要设置 {token_env} 环境变量"}
        
        g = Github(token)
        repo = g.get_repo(repo_path)
        pr = repo.get_pull(pr_number)
        
        # 获取当前用户信息
        current_user = g.get_user()
        
        # 检查是否是自己的PR
        is_own_pr = pr.user.login == current_user.login
        
        return {
            "status": "success",
            "pr_number": pr_number,
            "pr_author": pr.user.login,
            "current_user": current_user.login,
            "is_own_pr": is_own_pr,
            "pr_title": pr.title,
            "pr_state": pr.state,
            "can_approve": not is_own_pr,
            "token_used": token_env,
            "message": "这是您自己的PR，无法自己批准" if is_own_pr else "可以批准此PR"
        }
        
    except Exception as e:
        return {"error": f"检查 PR 作者失败: {str(e)}"}

def request_pr_review(repo_path: str, pr_number: int, reviewers: str = None, team_reviewers: str = None, token_env: str = "GITHUB_TOKEN") -> dict:
    """
    请求其他用户审查 PR
    
    Args:
        repo_path: 仓库路径，格式为 "owner/repo"
        pr_number: PR 编号
        reviewers: 审查者用户名列表 (JSON 字符串)（可选）
        team_reviewers: 团队审查者列表 (JSON 字符串)（可选）
        token_env: GitHub Token 环境变量名（默认 "GITHUB_TOKEN"）
    
    Returns:
        dict: 包含请求结果或错误信息
    """
    try:
        if reviewers and isinstance(reviewers, str):
            reviewers = json.loads(reviewers)
        if team_reviewers and isinstance(team_reviewers, str):
            team_reviewers = json.loads(team_reviewers)
        token = os.getenv(token_env)
        if not token:
            return {"error": f"需要设置 {token_env} 环境变量"}
        
        g = Github(token)
        repo = g.get_repo(repo_path)
        pr = repo.get_pull(pr_number)
        
        # 检查是否是自己的PR
        current_user = g.get_user()
        is_own_pr = pr.user.login == current_user.login
        
        if not is_own_pr:
            return {"error": "只能请求审查自己的PR"}
        
        # 如果没有指定审查者，尝试获取仓库的贡献者
        if not reviewers and not team_reviewers:
            try:
                contributors = [contributor.login for contributor in repo.get_contributors()]
                # 排除自己
                contributors = [user for user in contributors if user != current_user.login]
                if contributors:
                    reviewers = contributors[:3]  # 最多请求3个审查者
            except Exception:
                pass
        
        if not reviewers and not team_reviewers:
            return {"error": "没有可用的审查者，请手动指定 reviewers 或 team_reviewers 参数"}
        
        # 创建审查请求
        try:
            pr.create_review_request(reviewers=reviewers, team_reviewers=team_reviewers)
            
            return {
                "status": "success",
                "pr_number": pr_number,
                "requested_reviewers": reviewers or [],
                "requested_team_reviewers": team_reviewers or [],
                "token_used": token_env,
                "message": f"已请求审查 PR #{pr_number}"
            }
            
        except Exception as e:
            error_msg = str(e)
            if "Review cannot be requested" in error_msg:
                return {"error": "无法请求审查，可能是因为PR作者没有权限或审查者不可用"}
            else:
                return {"error": f"请求审查失败: {error_msg}"}
        
    except Exception as e:
        return {"error": f"请求 PR 审查失败: {str(e)}"}

def list_prs(
    repo_path: str,
    state: str = "open",
    sort: str = "created",
    direction: str = "desc",
    limit: int = 20,
    token_env: str = "GITHUB_TOKEN"
) -> dict:
    """
    列出仓库的 PR
    
    Args:
        repo_path: 仓库路径，格式为 "owner/repo"
        state: PR 状态，可选 "open", "closed", "all"（默认 "open"）
        sort: 排序方式，可选 "created", "updated", "popularity"（默认 "created"）
        direction: 排序方向，可选 "asc", "desc"（默认 "desc"）
        limit: 最大返回数量（默认 20）
        token_env: GitHub Token 环境变量名（默认 "GITHUB_TOKEN"）
    
    Returns:
        dict: 包含 PR 列表或错误信息
    """
    try:
        token = os.getenv(token_env)
        g = Github(token) if token else Github()
        repo = g.get_repo(repo_path)
        
        # 获取 PR 列表
        pulls = repo.get_pulls(state=state, sort=sort, direction=direction)
        
        pr_list = []
        count = 0
        for pr in pulls:
            if count >= limit:
                break
                
            pr_info = {
                "number": pr.number,
                "title": pr.title,
                "body": pr.body[:200] + "..." if pr.body and len(pr.body) > 200 else pr.body,
                "state": pr.state,
                "head_branch": pr.head.ref,
                "base_branch": pr.base.ref,
                "author": pr.user.login,
                "created_at": pr.created_at.isoformat(),
                "updated_at": pr.updated_at.isoformat(),
                "mergeable": pr.mergeable,
                "mergeable_state": pr.mergeable_state,
                "commits": pr.commits,
                "additions": pr.additions,
                "deletions": pr.deletions,
                "changed_files": pr.changed_files,
                "url": pr.html_url
            }
            
            # 获取审查状态
            try:
                reviews = pr.get_reviews()
                approvals = sum(1 for review in reviews if review.state == "APPROVED")
                changes_requested = sum(1 for review in reviews if review.state == "CHANGES_REQUESTED")
                
                pr_info["review_status"] = {
                    "approvals": approvals,
                    "changes_requested": changes_requested,
                    "total_reviews": reviews.totalCount
                }
            except Exception:
                pr_info["review_status"] = {"approvals": 0, "changes_requested": 0, "total_reviews": 0}
            
            pr_list.append(pr_info)
            count += 1
        
        return {
            "status": "success",
            "repo": repo_path,
            "state": state,
            "total_prs": len(pr_list),
            "prs": pr_list,
            "token_used": token_env
        }
        
    except Exception as e:
        return {"error": f"获取 PR 列表失败: {str(e)}"}


def review_pr_with_review_token(
    repo_path: str,
    pr_number: int,
    approve: bool = False,
    review_comment: str = None
) -> dict:
    """
    使用审查专用Token的 PR 审查工具
    
    Args:
        repo_path: 仓库路径，格式为 "owner/repo"
        pr_number: PR 编号
        approve: 是否批准 PR（默认 False）
        review_comment: 审查评论（可选）
    
    Returns:
        dict: 包含审查结果或错误信息
    """
    try:
        # 参数验证
        if not repo_path or not isinstance(repo_path, str):
            return {"error": "repo_path 必须是有效的字符串，格式为 'owner/repo'"}
        
        if not pr_number or not isinstance(pr_number, int):
            return {"error": "pr_number 必须是有效的整数"}
        
        # 使用审查专用Token
        token_env = "REVIEW_GITHUB_TOKEN"
        token = os.getenv(token_env)
        if not token:
            return {"error": f"需要设置 {token_env} 环境变量"}
        
        g = Github(token)
        repo = g.get_repo(repo_path)
        pr = repo.get_pull(pr_number)
        
        # 检查是否是自己的PR
        current_user = g.get_user()
        is_own_pr = pr.user.login == current_user.login
        
        if is_own_pr and approve:
            return {
                "error": "无法批准自己的PR",
                "pr_author": pr.user.login,
                "current_user": current_user.login,
                "token_used": token_env,
                "suggestion": "您可以：1) 使用 request_pr_review 请求其他用户审查，2) 只添加评论而不批准",
                "can_comment": True
            }
        
        # 获取 PR 文件变更
        files_changed = []
        for file in pr.get_files():
            files_changed.append({
                "filename": file.filename,
                "status": file.status,
                "additions": file.additions,
                "deletions": file.deletions,
                "changes": file.changes,
                "patch": file.patch[:1000] + "..." if len(file.patch) > 1000 else file.patch
            })
        
        # 获取 PR 详情
        pr_details = {
            "number": pr.number,
            "title": pr.title,
            "body": pr.body,
            "state": pr.state,
            "head_branch": pr.head.ref,
            "base_branch": pr.base.ref,
            "author": pr.user.login,
            "created_at": pr.created_at.isoformat(),
            "updated_at": pr.updated_at.isoformat(),
            "mergeable": pr.mergeable,
            "mergeable_state": pr.mergeable_state,
            "files_changed": files_changed,
            "commits": pr.commits,
            "additions": pr.additions,
            "deletions": pr.deletions,
            "changed_files": pr.changed_files
        }
        
        # 如果需要批准或添加评论
        if approve or review_comment:
            try:
                # 创建审查
                if approve:
                    pr.create_review(
                        body=review_comment or "LGTM! Approved by ADK Companion.",
                        event="APPROVE"
                    )
                    pr_details["review_action"] = "approved"
                elif review_comment:
                    pr.create_review(
                        body=review_comment,
                        event="COMMENT"
                    )
                    pr_details["review_action"] = "commented"
                    
            except Exception as e:
                return {"error": f"创建审查失败: {str(e)}"}
        
        return {
            "status": "success",
            "pr_details": pr_details,
            "token_used": token_env,
            "message": f"Successfully reviewed PR #{pr_number}"
        }
        
    except Exception as e:
        return {"error": f"审查 PR 失败: {str(e)}"}

def merge_pr_with_review_token(
    repo_path: str,
    pr_number: int,
    merge_method: str = "merge",
    commit_title: str = None,
    commit_message: str = None
) -> dict:
    """
    使用审查专用Token的 PR 合并工具
    
    Args:
        repo_path: 仓库路径，格式为 "owner/repo"
        pr_number: PR 编号
        merge_method: 合并方法，可选 "merge", "squash", "rebase"（默认 "merge"）
        commit_title: 合并提交标题（可选）
        commit_message: 合并提交消息（可选）
    
    Returns:
        dict: 包含合并结果或错误信息
    """
    try:
        # 参数验证
        if not repo_path or not isinstance(repo_path, str):
            return {"error": "repo_path 必须是有效的字符串，格式为 'owner/repo'"}
        
        if not pr_number or not isinstance(pr_number, int):
            return {"error": "pr_number 必须是有效的整数"}
        
        if merge_method not in ["merge", "squash", "rebase"]:
            return {"error": "merge_method 必须是 'merge', 'squash', 或 'rebase'"}
        
        # 使用审查专用Token
        token_env = "REVIEW_GITHUB_TOKEN"
        token = os.getenv(token_env)
        if not token:
            return {"error": f"需要设置 {token_env} 环境变量"}
        
        g = Github(token)
        repo = g.get_repo(repo_path)
        pr = repo.get_pull(pr_number)
        
        # 检查 PR 是否可合并
        if not pr.mergeable:
            return {
                "error": "PR 不可合并",
                "mergeable_state": pr.mergeable_state,
                "status": pr.raw_data.get('status', 'unknown')
            }
        
        # 检查是否有合并冲突
        if pr.mergeable_state == "dirty":
            return {"error": "PR 有合并冲突，无法自动合并"}
        
        # 检查是否需要 CI 通过
        if pr.mergeable_state == "blocked":
            # 获取状态检查
            status_checks = []
            try:
                for commit in pr.get_commits():
                    for status in commit.get_status().statuses:
                        status_checks.append({
                            "context": status.context,
                            "state": status.state,
                            "description": status.description,
                            "target_url": status.target_url
                        })
            except Exception:
                pass
            
            return {
                "error": "PR 被阻止合并，可能需要 CI 检查通过或审查批准",
                "status_checks": status_checks
            }
        
        try:
            # 确保参数格式正确
            if not commit_message:
                commit_message = f"Merge PR #{pr_number}"
            
            if not commit_title:
                commit_title = f"Merge pull request #{pr_number} from {pr.head.ref}"
            
            merge_result = pr.merge(
                commit_message=commit_message,
                commit_title=commit_title,
                merge_method=merge_method
            )
            
            return {
                "status": "success",
                "merged": merge_result.merged,
                "sha": merge_result.sha,
                "message": merge_result.message,
                "pr_number": pr_number,
                "merge_method": merge_method,
                "merged_at": merge_result.merged_at.isoformat() if hasattr(merge_result, "merged_at") and merge_result.merged_at else None,
                "token_used": token_env
            }
            
        except Exception as e:
            error_msg = str(e) if e else "未知错误"
            if not error_msg or error_msg == "None":
                error_msg = "合并失败，可能是参数错误或权限问题"
            
            # 提供更详细的错误信息
            if "Required status check" in error_msg:
                return {"error": "合并失败：必需的状态检查未通过"}
            elif "Review required" in error_msg:
                return {"error": "合并失败：需要代码审查"}
            elif "not authorized" in error_msg.lower():
                return {"error": "合并失败：没有权限合并此 PR"}
            elif "merge conflict" in error_msg.lower():
                return {"error": "合并失败：存在合并冲突"}
            elif "Base branch was modified" in error_msg:
                return {"error": "合并失败：基础分支已被修改，请更新PR"}
            elif "Pull Request is not mergeable" in error_msg:
                return {"error": "合并失败：PR不可合并"}
            else:
                return {"error": f"合并失败: {error_msg}"}
        
    except Exception as e:
        # 外层异常处理
        error_msg = str(e) if e else "未知错误"
        if not error_msg or error_msg == "None":
            error_msg = "合并PR操作失败，可能是参数错误或网络问题"
        return {"error": f"合并 PR 失败: {error_msg}"}

def check_pr_author_with_review_token(
    repo_path: str,
    pr_number: int
) -> dict:
    """
    使用审查专用Token检查 PR 作者信息
    
    Args:
        repo_path: 仓库路径，格式为 "owner/repo"
        pr_number: PR 编号
    
    Returns:
        dict: 包含 PR 作者信息和当前用户信息
    """
    try:
        # 参数验证
        if not repo_path or not isinstance(repo_path, str):
            return {"error": "repo_path 必须是有效的字符串，格式为 'owner/repo'"}
        
        if not pr_number or not isinstance(pr_number, int):
            return {"error": "pr_number 必须是有效的整数"}
        
        # 使用审查专用Token
        token_env = "REVIEW_GITHUB_TOKEN"
        token = os.getenv(token_env)
        if not token:
            return {"error": f"需要设置 {token_env} 环境变量"}
        
        g = Github(token)
        repo = g.get_repo(repo_path)
        pr = repo.get_pull(pr_number)
        
        # 获取当前用户信息
        current_user = g.get_user()
        
        # 检查是否是自己的PR
        is_own_pr = pr.user.login == current_user.login
        
        return {
            "status": "success",
            "pr_number": pr_number,
            "pr_author": pr.user.login,
            "current_user": current_user.login,
            "is_own_pr": is_own_pr,
            "pr_title": pr.title,
            "pr_state": pr.state,
            "can_approve": not is_own_pr,
            "token_used": token_env,
            "message": "这是您自己的PR，无法自己批准" if is_own_pr else "可以批准此PR"
        }
        
    except Exception as e:
        return {"error": f"检查 PR 作者失败: {str(e)}"}

def request_pr_review_with_review_token(
    repo_path: str,
    pr_number: int,
    reviewers: str = None,
    team_reviewers: str = None
) -> dict:
    """
    使用审查专用Token请求其他用户审查 PR
    
    Args:
        repo_path: 仓库路径，格式为 "owner/repo"
        pr_number: PR 编号
        reviewers: 审查者用户名列表 (JSON 字符串)（可选）
        team_reviewers: 团队审查者列表 (JSON 字符串)（可选）
    
    Returns:
        dict: 包含请求结果或错误信息
    """
    return request_pr_review(
        repo_path=repo_path,
        pr_number=pr_number,
        reviewers=reviewers,
        team_reviewers=team_reviewers,
        token_env="REVIEW_GITHUB_TOKEN"
    )

def list_prs_with_review_token(
    repo_path: str,
    state: str = "open",
    sort: str = "created",
    direction: str = "desc",
    limit: int = 20
) -> dict:
    """
    使用审查专用Token列出仓库的 PR
    
    Args:
        repo_path: 仓库路径，格式为 "owner/repo"
        state: PR 状态，可选 "open", "closed", "all"（默认 "open"）
        sort: 排序方式，可选 "created", "updated", "popularity"（默认 "created"）
        direction: 排序方向，可选 "asc", "desc"（默认 "desc"）
        limit: 最大返回数量（默认 20）
    
    Returns:
        dict: 包含 PR 列表或错误信息
    """
    return list_prs(
        repo_path=repo_path,
        state=state,
        sort=sort,
        direction=direction,
        limit=limit,
        token_env="REVIEW_GITHUB_TOKEN"
    )


def list_branches(repo_path: str, token_env: str = "GITHUB_TOKEN") -> dict:
    """
    获取指定仓库的分支列表

    Args:
        repo_path: 仓库路径，格式为 "owner/repo"
        token_env: GitHub Token 环境变量名（默认 "GITHUB_TOKEN"）

    Returns:
        dict: 包含分支列表或错误信息
    """
    try:
        token = os.getenv(token_env)
        g = Github(token) if token else Github()
        repo = g.get_repo(repo_path)
        branches = repo.get_branches()
        branch_list = [branch.name for branch in branches]
        return {
            "status": "success",
            "repo": repo_path,
            "branches": branch_list
        }
    except Exception as e:
        return {"error": f"获取分支列表失败: {str(e)}"}

def inspect_installed_package(package_name: str) -> dict:
    """
    检查已安装的 Python 包信息（版本、依赖、元数据）
    
    Args:
        package_name: 包名
    
    Returns:
        dict: 包信息
    """
    try:
        import importlib.metadata
        
        try:
            dist = importlib.metadata.distribution(package_name)
            metadata = dist.metadata
            
            return {
                "name": metadata.get("Name"),
                "version": metadata.get("Version"),
                "summary": metadata.get("Summary"),
                "home_page": metadata.get("Home-page"),
                "author": metadata.get("Author"),
                "license": metadata.get("License"),
                "requires_dist": dist.requires if dist.requires else [],
                "files_count": len(dist.files) if dist.files else 0,
                "location": str(dist.locate_file(""))
            }
        except importlib.metadata.PackageNotFoundError:
            return {"error": f"包 '{package_name}' 未安装"}
            
    except Exception as e:
        return {"error": f"检查包信息失败: {str(e)}"}

def analyze_file_imports(file_path: str, content: str = None) -> dict:
    """
    分析 Python 文件中的导入依赖
    
    Args:
        file_path: 文件路径（用于显示）
        content: 文件内容（如果未提供，尝试从 file_path 读取，但这需要本地文件访问，通常配合 read_github_repo 使用）
    
    Returns:
        dict: 导入列表和分析结果
    """
    import ast
    
    try:
        if content is None:
            # 尝试本地读取，如果失败则返回错误
            if os.path.exists(file_path):
                with open(file_path, 'r', encoding='utf-8') as f:
                    content = f.read()
            else:
                return {"error": "需要提供 content 参数或本地文件不存在"}
        
        tree = ast.parse(content)
        
        imports = []
        from_imports = []
        
        for node in ast.walk(tree):
            if isinstance(node, ast.Import):
                for name in node.names:
                    imports.append({
                        "name": name.name,
                        "asname": name.asname
                    })
            elif isinstance(node, ast.ImportFrom):
                module = node.module if node.module else ""
                for name in node.names:
                    from_imports.append({
                        "module": module,
                        "name": name.name,
                        "asname": name.asname,
                        "level": node.level
                    })
                    
        # 提取顶级依赖
        dependencies = set()
        for imp in imports:
            dependencies.add(imp["name"].split('.')[0])
        for imp in from_imports:
            if imp["module"]:
                dependencies.add(imp["module"].split('.')[0])
        
        return {
            "file": file_path,
            "imports": imports,
            "from_imports": from_imports,
            "detected_dependencies": list(dependencies)
        }
        
    except Exception as e:
        return {"error": f"分析导入失败: {str(e)}"}
