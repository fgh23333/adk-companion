"""
ADK Companion - 工具集
"""

import os
from pathlib import Path
from typing import Optional
from github import Github
from dotenv import load_dotenv
load_dotenv()

def find_adk_site_packages() -> Optional[Path]:
    """查找当前 Python 环境下 ADK 库的 site-packages 路径"""
    try:
        import google.adk
        adk_path = Path(google.adk.__file__).parent
        return adk_path
    except ImportError:
        return None

def read_adk_codebase(keyword: str, max_results: int = 10) -> list[str]:
    """在 ADK 源码中搜索关键词并返回匹配的文件内容片段"""
    adk_path = find_adk_site_packages()
    if not adk_path:
        return ["ADK 未安装在当前环境中"]
    
    results = []
    try:
        # 简单实现：遍历 .py 文件并搜索关键词
        for py_file in adk_path.rglob("*.py"):
            if len(results) >= max_results:
                break
            try:
                content = py_file.read_text(encoding="utf-8")
                if keyword.lower() in content.lower():
                    results.append(f"文件: {py_file.relative_to(adk_path)}\n{content[:500]}...")
            except Exception:
                continue
    except Exception as e:
        results.append(f"搜索出错: {e}")
    
    return results[:max_results]

def check_upstream_release() -> dict:
    """检查上游 ADK 仓库的最新发布版本"""
    try:
        # 使用 GitHub API 获取最新发布
        token = os.getenv("GITHUB_TOKEN")
        g = Github(token) if token else Github()
        repo = g.get_repo("google/adk-python")
        latest_release = repo.get_latest_release()
        
        return {
            "tag_name": latest_release.tag_name,
            "published_at": latest_release.published_at.isoformat(),
            "body": latest_release.body[:1000] + "..." if len(latest_release.body) > 1000 else latest_release.body
        }
    except Exception as e:
        return {"error": str(e)}

def generate_pr(
    title: str,
    description: str,
    files_to_modify: dict = None,
    files_to_create: dict = None,
    base_branch: str = "main",
    branch_prefix: str = "feature"
) -> dict:
    """
    通用 PR 生成器 - 创建分支、修改/创建文件、提交并创建 PR
    
    Args:
        title: PR 标题
        description: PR 描述
        files_to_modify: 要修改的文件字典 {文件路径: 新内容}
        files_to_create: 要创建的文件字典 {文件路径: 文件内容}
        base_branch: 目标分支（默认 main）
        branch_prefix: 分支前缀（默认 feature）
    
    Returns:
        dict: 包含 PR 信息或错误信息
    """
    try:
        import git
        from datetime import datetime
        
        # 获取当前仓库路径
        repo_path = Path(__file__).parent.parent.parent
        repo = git.Repo(repo_path)
        
        # 生成分支名（基于标题，简化处理）
        safe_title = "".join(c for c in title if c.isalnum() or c in (' ', '-', '_')).rstrip()
        branch_name = f"{branch_prefix}/{'-'.join(safe_title.lower().split()[:5])}"
        current_branch = repo.active_branch.name
        
        # 切换到新分支
        if branch_name in [ref.name for ref in repo.refs]:
            # 分支已存在，删除并重新创建
            repo.delete_head(branch_name, force=True)
        new_branch = repo.create_head(branch_name)
        new_branch.checkout()
        
        # 修改文件
        files_added = []
        if files_to_modify:
            for file_path, new_content in files_to_modify.items():
                full_path = repo_path / file_path
                if full_path.exists():
                    with open(full_path, 'w', encoding='utf-8') as f:
                        f.write(new_content)
                    files_added.append(file_path)
        
        # 创建新文件
        if files_to_create:
            for file_path, content in files_to_create.items():
                full_path = repo_path / file_path
                # 确保目录存在
                full_path.parent.mkdir(parents=True, exist_ok=True)
                with open(full_path, 'w', encoding='utf-8') as f:
                    f.write(content)
                files_added.append(file_path)
        
        # 提交更改
        if files_added:
            repo.index.add(files_added)
            
            commit_message = f"""{title}

{description}

---
Generated by ADK Companion at {datetime.now().isoformat()}
"""
            repo.index.commit(commit_message)
        
        # 推送到远程
        origin = repo.remote(name='origin')
        origin.push(branch_name)
        
        # 创建 PR（需要 GitHub Token）
        token = os.getenv("GITHUB_TOKEN")
        if token:
            g = Github(token)
            repo_name = repo.remotes.origin.url.split('/')[-1].replace('.git', '')
            if '/' in repo_name:
                owner, name = repo_name.split('/')
            else:
                # 尝试从 git remote 获取完整信息
                remote_url = repo.remotes.origin.url
                if 'github.com' in remote_url:
                    owner = remote_url.split('github.com/')[1].split('/')[0]
                    name = remote_url.split('github.com/')[1].split('/')[1].replace('.git', '')
                else:
                    return {"error": "无法确定仓库名称"}
            
            github_repo = g.get_repo(f"{owner}/{name}")
            pr = github_repo.create_pull(
                title=title,
                body=commit_message,
                head=branch_name,
                base=base_branch
            )
            
            # 切换回原分支
            repo.branches[current_branch].checkout()
            
            return {
                "status": "success",
                "pr_url": pr.html_url,
                "pr_number": pr.number,
                "branch_name": branch_name,
                "message": f"Created PR #{pr.number}: {title}"
            }
        else:
            # 切换回原分支
            repo.branches[current_branch].checkout()
            return {
                "status": "partial_success",
                "pr_url": None,
                "branch_name": branch_name,
                "message": f"Branch {branch_name} created and pushed, but no GitHub token to create PR"
            }
            
    except ImportError:
        return {"error": "需要安装 GitPython: pip install GitPython"}
    except Exception as e:
        # 尝试切换回原分支
        try:
            repo.branches[current_branch].checkout()
        except:
            pass
        return {"error": f"创建 PR 失败: {str(e)}"}

def generate_evolution_pr(target_version: str, sample_code: str, dependency_changes: str) -> dict:
    """
    生成 ADK 升级 PR - 使用通用 PR 生成器的特化版本
    """
    from datetime import datetime
    
    title = f"feat: upgrade to ADK {target_version}"
    description = f"""Upgrade google-adk to version {target_version}

Changes:
- Update google-adk to version {target_version}
- Add new feature sample: new_feature_{target_version}.py

{dependency_changes}"""
    
    # 修改 requirements.txt
    files_to_modify = {}
    requirements_path = "requirements.txt"
    if (Path(__file__).parent.parent.parent / requirements_path).exists():
        with open(Path(__file__).parent.parent.parent / requirements_path, 'r', encoding='utf-8') as f:
            content = f.read()
        
        lines = content.split('\n')
        updated_lines = []
        for line in lines:
            if line.startswith('google-adk'):
                updated_lines.append(f'google-adk=={target_version}')
            else:
                updated_lines.append(line)
        
        files_to_modify[requirements_path] = '\n'.join(updated_lines)
    
    # 创建示例文件
    files_to_create = {
        f"samples/new_feature_{target_version}.py": f'''"""
新功能示例 - 版本 {target_version}
生成时间: {datetime.now().isoformat()}
"""

{sample_code}

if __name__ == "__main__":
    # 示例用法
    print("新功能示例运行完成")
'''
    }
    
    return generate_pr(
        title=title,
        description=description,
        files_to_modify=files_to_modify,
        files_to_create=files_to_create,
        branch_prefix="chore"
    )