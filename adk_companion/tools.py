"""
ADK Companion - å·¥å…·é›†
"""

import os
import json
from pathlib import Path
from typing import Optional
from github import Github
from dotenv import load_dotenv
load_dotenv()

def find_adk_site_packages() -> Optional[Path]:
    """æŸ¥æ‰¾å½“å‰ Python ç¯å¢ƒä¸‹ ADK åº“çš„ site-packages è·¯å¾„"""
    try:
        import google.adk
        adk_path = Path(google.adk.__file__).parent
        return adk_path
    except ImportError:
        return None

def read_adk_codebase(keyword: str, max_results: int = 10) -> list[str]:
    """åœ¨ ADK æºç ä¸­æœç´¢å…³é”®è¯å¹¶è¿”å›åŒ¹é…çš„æ–‡ä»¶å†…å®¹ç‰‡æ®µ"""
    adk_path = find_adk_site_packages()
    if not adk_path:
        return ["ADK æœªå®‰è£…åœ¨å½“å‰ç¯å¢ƒä¸­"]
    
    results = []
    try:
        # ç®€å•å®ç°ï¼šéå† .py æ–‡ä»¶å¹¶æœç´¢å…³é”®è¯
        for py_file in adk_path.rglob("*.py"):
            if len(results) >= max_results:
                break
            try:
                content = py_file.read_text(encoding="utf-8")
                if keyword.lower() in content.lower():
                    results.append(f"æ–‡ä»¶: {py_file.relative_to(adk_path)}\n{content[:500]}...")
            except Exception:
                continue
    except Exception as e:
        results.append(f"æœç´¢å‡ºé”™: {e}")
    
    return results[:max_results]

def check_upstream_release() -> dict:
    """æ£€æŸ¥ä¸Šæ¸¸ ADK ä»“åº“çš„æœ€æ–°å‘å¸ƒç‰ˆæœ¬"""
    try:
        # ä½¿ç”¨ GitHub API è·å–æœ€æ–°å‘å¸ƒ
        token = os.getenv("GITHUB_TOKEN")
        g = Github(token) if token else Github()
        repo = g.get_repo("google/adk-python")
        latest_release = repo.get_latest_release()
        
        return {
            "tag_name": latest_release.tag_name,
            "published_at": latest_release.published_at.isoformat(),
            "body": latest_release.body[:1000] + "..." if len(latest_release.body) > 1000 else latest_release.body
        }
    except Exception as e:
        return {"error": str(e)}

def generate_pr(
    title: str,
    description: str,
    files_to_modify: str = None,
    files_to_create: str = None,
    base_branch: str = "main",
    branch_prefix: str = "feature",
    target_repo: str = None
) -> dict:
    """
    é€šç”¨ PR ç”Ÿæˆå™¨ - ç›´æ¥å¯¹è¿œç¨‹ä»“åº“åˆ›å»º PR
    
    Args:
        title: PR æ ‡é¢˜
        description: PR æè¿°
        files_to_modify: è¦ä¿®æ”¹çš„æ–‡ä»¶å­—å…¸ (JSON å­—ç¬¦ä¸²) {æ–‡ä»¶è·¯å¾„: æ–°å†…å®¹}
        files_to_create: è¦åˆ›å»ºçš„æ–‡ä»¶å­—å…¸ (JSON å­—ç¬¦ä¸²) {æ–‡ä»¶è·¯å¾„: æ–‡ä»¶å†…å®¹}
        base_branch: ç›®æ ‡åˆ†æ”¯ï¼ˆé»˜è®¤ mainï¼‰
        branch_prefix: åˆ†æ”¯å‰ç¼€ï¼ˆé»˜è®¤ featureï¼‰
        target_repo: ç›®æ ‡ä»“åº“ï¼Œæ ¼å¼ä¸º "owner/repo"ï¼Œå¦‚æœä¸æŒ‡å®šåˆ™å°è¯•ä»ç¯å¢ƒè·å–
    
    Returns:
        dict: åŒ…å« PR ä¿¡æ¯æˆ–é”™è¯¯ä¿¡æ¯
    """
    try:
        from datetime import datetime
        
        if files_to_modify and isinstance(files_to_modify, str):
            files_to_modify = json.loads(files_to_modify)
        if files_to_create and isinstance(files_to_create, str):
            files_to_create = json.loads(files_to_create)
        
        # æ£€æŸ¥ GitHub Token
        token = os.getenv("GITHUB_TOKEN")
        if not token:
            return {"error": "éœ€è¦è®¾ç½® GITHUB_TOKEN ç¯å¢ƒå˜é‡"}
        
        # ç¡®å®šç›®æ ‡ä»“åº“
        if not target_repo:
            return {"error": "éœ€è¦æŒ‡å®š target_repo å‚æ•°ï¼Œæ ¼å¼ä¸º 'owner/repo'"}
        
        # éªŒè¯ä»“åº“æ ¼å¼
        if '/' not in target_repo or len(target_repo.split('/')) != 2:
            return {"error": "target_repo æ ¼å¼é”™è¯¯ï¼Œåº”ä¸º 'owner/repo'"}
        
        g = Github(token)
        
        # éªŒè¯ä»“åº“å­˜åœ¨ä¸”å¯è®¿é—®
        try:
            github_repo = g.get_repo(target_repo)
        except Exception as e:
            return {"error": f"æ— æ³•è®¿é—®ä»“åº“ {target_repo}: {str(e)}"}
        
        # å¦‚æœæ²¡æœ‰æ–‡ä»¶æ“ä½œï¼Œç›´æ¥åˆ›å»ºä¸€ä¸ªç©ºçš„ PR
        if not files_to_modify and not files_to_create:
            try:
                # åˆ›å»ºä¸€ä¸ªç®€å•çš„ PRï¼ˆä¸æ¶‰åŠæ–‡ä»¶æ›´æ”¹ï¼‰
                pr = github_repo.create_pull(
                    title=title,
                    body=f"{description}\n\n---\nGenerated by ADK Companion at {datetime.now().isoformat()}",
                    head=base_branch,  # ä½¿ç”¨åŒä¸€åˆ†æ”¯ä½œä¸ºæºå’Œç›®æ ‡
                    base=base_branch
                )
                return {
                    "status": "success",
                    "pr_url": pr.html_url,
                    "pr_number": pr.number,
                    "message": f"Created PR #{pr.number}: {title}"
                }
            except Exception as e:
                return {"error": f"åˆ›å»º PR å¤±è´¥: {str(e)}"}
        
        # æœ‰æ–‡ä»¶æ“ä½œæ—¶ï¼Œéœ€è¦é€šè¿‡ GitHub API ç›´æ¥åˆ›å»ºæ–‡ä»¶
        try:
            # ç”Ÿæˆåˆ†æ”¯å
            safe_title = "".join(c for c in title if c.isalnum() or c in (' ', '-', '_')).rstrip()
            if not safe_title:
                safe_title = "update"
            branch_name = f"{branch_prefix}/{ '-'.join(safe_title.lower().split()[:5])}"
            
            # è·å–åŸºç¡€åˆ†æ”¯çš„æœ€æ–°æäº¤
            base_branch_ref = github_repo.get_branch(base_branch)
            base_sha = base_branch_ref.commit.sha
            
            # åˆ›å»ºæ–°åˆ†æ”¯
            try:
                github_repo.create_git_ref(
                    ref=f"refs/heads/{branch_name}",
                    sha=base_sha
                )
            except Exception as e:
                if "already exists" in str(e):
                    # åˆ†æ”¯å·²å­˜åœ¨ï¼Œåˆ é™¤åé‡æ–°åˆ›å»º
                    try:
                        github_repo.get_git_ref(f"heads/{branch_name}").delete()
                        github_repo.create_git_ref(
                            ref=f"refs/heads/{branch_name}",
                            sha=base_sha
                        )
                    except Exception as delete_e:
                        return {"error": f"æ— æ³•åˆ›å»ºåˆ†æ”¯ {branch_name}: {str(delete_e)}"}
                else:
                    return {"error": f"æ— æ³•åˆ›å»ºåˆ†æ”¯ {branch_name}: {str(e)}"}
            
            # æ›´æ–°æˆ–åˆ›å»ºæ–‡ä»¶
            all_files_changed = []
            
            # å¤„ç†è¦ä¿®æ”¹çš„æ–‡ä»¶
            if files_to_modify:
                for file_path, new_content in files_to_modify.items():
                    try:
                        # è·å–å½“å‰æ–‡ä»¶å†…å®¹ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
                        try:
                            current_file = github_repo.get_contents(file_path, ref=base_branch)
                            github_repo.update_file(
                                path=file_path,
                                message=f"Update {file_path}",
                                content=new_content,
                                sha=current_file.sha,
                                branch=branch_name
                            )
                        except Exception:
                            # æ–‡ä»¶ä¸å­˜åœ¨ï¼Œåˆ›å»ºæ–°æ–‡ä»¶
                            github_repo.create_file(
                                path=file_path,
                                message=f"Create {file_path}",
                                content=new_content,
                                branch=branch_name
                            )
                        all_files_changed.append(file_path)
                    except Exception as e:
                        return {"error": f"å¤„ç†æ–‡ä»¶ {file_path} å¤±è´¥: {str(e)}"}
            
            # å¤„ç†è¦åˆ›å»ºçš„æ–‡ä»¶
            if files_to_create:
                for file_path, content in files_to_create.items():
                    try:
                        github_repo.create_file(
                            path=file_path,
                            message=f"Add {file_path}",
                            content=content,
                            branch=branch_name
                        )
                        all_files_changed.append(file_path)
                    except Exception as e:
                        return {"error": f"åˆ›å»ºæ–‡ä»¶ {file_path} å¤±è´¥: {str(e)}"}
            
            # åˆ›å»º PR
            commit_message = f"""{title}\n\n{description}\n\n---\nGenerated by ADK Companion at {datetime.now().isoformat()}\nFiles changed: {', '.join(all_files_changed)}"""
            
            pr = github_repo.create_pull(
                title=title,
                body=commit_message,
                head=branch_name,
                base=base_branch
            )
            
            return {
                "status": "success",
                "pr_url": pr.html_url,
                "pr_number": pr.number,
                "branch_name": branch_name,
                "files_changed": all_files_changed,
                "message": f"Created PR #{pr.number}: {title}"
            }
            
        except Exception as e:
            return {"error": f"é€šè¿‡ GitHub API æ“ä½œå¤±è´¥: {str(e)}"}
    except Exception as e:
        return {"error": f"ç”Ÿæˆ PR æ—¶å‡ºé”™: {str(e)}"}

def read_github_repo(
    file_path: str = None,
    branch: str = "main",
    max_files: int = 50
) -> dict:
    """
    è¯»å– GitHub ä»“åº“ "fgh23333/adk-companion" çš„é¡¹ç›®ç»“æ„æˆ–æŒ‡å®šæ–‡ä»¶å†…å®¹
    
    Args:
        file_path: æŒ‡å®šæ–‡ä»¶è·¯å¾„ï¼ˆç›¸å¯¹äºä»“åº“æ ¹ç›®å½•ï¼‰ï¼Œå¦‚æœä¸ºç©ºåˆ™è¿”å›ç›®å½•ç»“æ„
        branch: åˆ†æ”¯åï¼Œé»˜è®¤ä¸º main
        max_files: æœ€å¤§æ–‡ä»¶æ•°é‡é™åˆ¶ï¼ˆä»…åœ¨è¯»å–ç›®å½•ç»“æ„æ—¶ç”Ÿæ•ˆï¼‰
    
    Returns:
        dict: åŒ…å«æ–‡ä»¶ç»“æ„æˆ–æ–‡ä»¶å†…å®¹çš„å­—å…¸
    """
    try:
        token = os.getenv("GITHUB_TOKEN")
        g = Github(token) if token else Github()
        
        repo_path = "fgh23333/adk-companion"
        
        # è·å–ä»“åº“å¯¹è±¡
        repo = g.get_repo(repo_path)
        
        if file_path:
            # è¯»å–æŒ‡å®šæ–‡ä»¶å†…å®¹
            try:
                file_content = repo.get_contents(file_path, ref=branch)
                if file_content.type == "file":
                    return {
                        "file_path": file_path,
                        "content": file_content.decoded_content.decode('utf-8'),
                        "size": file_content.size,
                        "sha": file_content.sha
                    }
                else:
                    return {"error": f"'{file_path}' æ˜¯ä¸€ä¸ªç›®å½•ï¼Œä¸æ˜¯æ–‡ä»¶"}
            except Exception as e:
                return {"error": f"è¯»å–æ–‡ä»¶ '{file_path}' å¤±è´¥: {str(e)}"}
        else:
            # è·å–ç›®å½•ç»“æ„
            try:
                file_tree = []
                contents = repo.get_contents("", ref=branch)
                
                def process_directory(contents, prefix="", depth=0):
                    if depth > 3 or len(file_tree) >= max_files:  # é™åˆ¶æ·±åº¦å’Œæ•°é‡
                        return
                    
                    for content in contents:
                        if len(file_tree) >= max_files:
                            break
                            
                        if content.type == "dir":
                            file_tree.append({
                                "type": "dir",
                                "path": f"{prefix}{content.name}/",
                                "size": 0
                            })
                            
                            # é€’å½’è·å–å­ç›®å½•å†…å®¹ï¼ˆé™åˆ¶æ·±åº¦ï¼‰
                            if depth < 2:
                                try:
                                    sub_contents = repo.get_contents(content.path, ref=branch)
                                    process_directory(sub_contents, f"{prefix}{content.name}/", depth + 1)
                                except:
                                    continue
                        else:
                            file_tree.append({
                                "type": "file",
                                "path": f"{prefix}{content.name}",
                                "size": content.size,
                                "sha": content.sha
                            })
                
                process_directory(contents)
                
                return {
                    "repo": repo_path,
                    "branch": branch,
                    "total_files": len([f for f in file_tree if f["type"] == "file"]),
                    "total_dirs": len([f for f in file_tree if f["type"] == "dir"]),
                    "file_tree": file_tree[:max_files]
                }
                
            except Exception as e:
                return {"error": f"è·å–ç›®å½•ç»“æ„å¤±è´¥: {str(e)}"}
                
    except Exception as e:
        return {"error": f"GitHub API è°ƒç”¨å¤±è´¥: {str(e)}"}

def generate_evolution_pr(target_version: str, sample_code: str, dependency_changes: str, target_repo: str = None) -> dict:
    """
    ç”Ÿæˆ ADK å‡çº§ PR - ä½¿ç”¨é€šç”¨ PR ç”Ÿæˆå™¨çš„ç‰¹åŒ–ç‰ˆæœ¬
    
    Args:
        target_version: ç›®æ ‡ç‰ˆæœ¬å·
        sample_code: ç¤ºä¾‹ä»£ç å†…å®¹
        dependency_changes: ä¾èµ–å˜æ›´è¯´æ˜
        target_repo: ç›®æ ‡ä»“åº“ï¼Œæ ¼å¼ä¸º "owner/repo"
    """
    from datetime import datetime
    
    title = f"feat: upgrade to ADK {target_version}"
    description = f"""Upgrade google-adk to version {target_version}\n\nChanges:\n- Update google-adk to version {target_version}\n- Add new feature sample: new_feature_{target_version}.py\n\n{dependency_changes}"""
    
    # ä¿®æ”¹ requirements.txt
    files_to_modify = {}
    requirements_path = "requirements.txt"
    if (Path(__file__).parent.parent.parent / requirements_path).exists():
        with open(Path(__file__).parent.parent.parent / requirements_path, 'r', encoding='utf-8') as f:
            content = f.read()
        
        lines = content.split('\n')
        updated_lines = []
        for line in lines:
            if line.startswith('google-adk'):
                updated_lines.append(f'google-adk=={target_version}')
            else:
                updated_lines.append(line)
        
        files_to_modify[requirements_path] = '\n'.join(updated_lines)
    
    # åˆ›å»ºç¤ºä¾‹æ–‡ä»¶
    files_to_create = {
        f"samples/new_feature_{target_version}.py": f'''"""\næ–°åŠŸèƒ½ç¤ºä¾‹ - ç‰ˆæœ¬ {target_version}\nç”Ÿæˆæ—¶é—´: {datetime.now().isoformat()}\n"""\n\n{sample_code}\n\nif __name__ == "__main__":\n    # ç¤ºä¾‹ç”¨æ³•\n    print("æ–°åŠŸèƒ½ç¤ºä¾‹è¿è¡Œå®Œæˆ")\n'''
    }
    
    return generate_pr(
        title=title,
        description=description,
        files_to_modify=json.dumps(files_to_modify) if files_to_modify else None,
        files_to_create=json.dumps(files_to_create) if files_to_create else None,
        branch_prefix="chore",
        target_repo=target_repo
    )

def review_pr(
    repo_path: str,
    pr_number: int,
    approve: bool = False,
    review_comment: str = None,
    token_env: str = "GITHUB_TOKEN"
) -> dict:
    """
    å®¡æŸ¥ PR å¹¶å¯é€‰æ‹©æ‰¹å‡†æˆ–æ·»åŠ è¯„è®º
    
    Args:
        repo_path: ä»“åº“è·¯å¾„ï¼Œæ ¼å¼ä¸º "owner/repo"
        pr_number: PR ç¼–å·
        approve: æ˜¯å¦æ‰¹å‡† PRï¼ˆé»˜è®¤ Falseï¼‰
        review_comment: å®¡æŸ¥è¯„è®ºï¼ˆå¯é€‰ï¼‰
        token_env: GitHub Token ç¯å¢ƒå˜é‡åï¼ˆé»˜è®¤ "GITHUB_TOKEN"ï¼‰
    
    Returns:
        dict: åŒ…å«å®¡æŸ¥ç»“æœæˆ–é”™è¯¯ä¿¡æ¯
    """
    try:
        token = os.getenv(token_env)
        if not token:
            return {"error": f"éœ€è¦è®¾ç½® {token_env} ç¯å¢ƒå˜é‡"}
        
        g = Github(token)
        repo = g.get_repo(repo_path)
        pr = repo.get_pull(pr_number)
        
        # æ£€æŸ¥æ˜¯å¦æ˜¯è‡ªå·±çš„PR
        current_user = g.get_user()
        is_own_pr = pr.user.login == current_user.login
        
        if is_own_pr and approve:
            return {
                "error": "æ— æ³•æ‰¹å‡†è‡ªå·±çš„PR",
                "pr_author": pr.user.login,
                "current_user": current_user.login,
                "token_used": token_env,
                "suggestion": "æ‚¨å¯ä»¥ï¼š1) ä½¿ç”¨ request_pr_review è¯·æ±‚å…¶ä»–ç”¨æˆ·å®¡æŸ¥ï¼Œ2) åªæ·»åŠ è¯„è®ºè€Œä¸æ‰¹å‡†",
                "can_comment": True
            }
        
        # è·å– PR æ–‡ä»¶å˜æ›´
        files_changed = []
        for file in pr.get_files():
            files_changed.append({
                "filename": file.filename,
                "status": file.status,
                "additions": file.additions,
                "deletions": file.deletions,
                "changes": file.changes,
                "patch": file.patch[:1000] + "..." if len(file.patch) > 1000 else file.patch
            })
        
        # è·å– PR è¯¦æƒ…
        pr_details = {
            "number": pr.number,
            "title": pr.title,
            "body": pr.body,
            "state": pr.state,
            "head_branch": pr.head.ref,
            "base_branch": pr.base.ref,
            "author": pr.user.login,
            "created_at": pr.created_at.isoformat(),
            "updated_at": pr.updated_at.isoformat(),
            "mergeable": pr.mergeable,
            "mergeable_state": pr.mergeable_state,
            "files_changed": files_changed,
            "commits": pr.commits,
            "additions": pr.additions,
            "deletions": pr.deletions,
            "changed_files": pr.changed_files
        }
        
        # å¦‚æœéœ€è¦æ‰¹å‡†æˆ–æ·»åŠ è¯„è®º
        if approve or review_comment:
            try:
                # åˆ›å»ºå®¡æŸ¥
                if approve:
                    pr.create_review(
                        body=review_comment or "LGTM! Approved by ADK Companion.",
                        event="APPROVE"
                    )
                    pr_details["review_action"] = "approved"
                elif review_comment:
                    pr.create_review(
                        body=review_comment,
                        event="COMMENT"
                    )
                    pr_details["review_action"] = "commented"
                    
            except Exception as e:
                return {"error": f"åˆ›å»ºå®¡æŸ¥å¤±è´¥: {str(e)}"}
        
        return {
            "status": "success",
            "pr_details": pr_details,
            "token_used": token_env,
            "message": f"Successfully reviewed PR #{pr_number}"
        }
        
    except Exception as e:
        return {"error": f"å®¡æŸ¥ PR å¤±è´¥: {str(e)}"}

def merge_pr(
    repo_path: str,
    pr_number: int,
    merge_method: str = "merge",
    commit_title: str = None,
    commit_message: str = None,
    token_env: str = "GITHUB_TOKEN"
) -> dict:
    """
    åˆå¹¶ PR
    
    Args:
        repo_path: ä»“åº“è·¯å¾„ï¼Œæ ¼å¼ä¸º "owner/repo"
        pr_number: PR ç¼–å·
        merge_method: åˆå¹¶æ–¹æ³•ï¼Œå¯é€‰ "merge", "squash", "rebase"ï¼ˆé»˜è®¤ "merge"ï¼‰
        commit_title: åˆå¹¶æäº¤æ ‡é¢˜ï¼ˆå¯é€‰ï¼‰
        commit_message: åˆå¹¶æäº¤æ¶ˆæ¯ï¼ˆå¯é€‰ï¼‰
        token_env: GitHub Token ç¯å¢ƒå˜é‡åï¼ˆé»˜è®¤ "GITHUB_TOKEN"ï¼‰
    
    Returns:
        dict: åŒ…å«åˆå¹¶ç»“æœæˆ–é”™è¯¯ä¿¡æ¯
    """
    try:
        token = os.getenv(token_env)
        if not token:
            return {"error": f"éœ€è¦è®¾ç½® {token_env} ç¯å¢ƒå˜é‡"}
        
        g = Github(token)
        repo = g.get_repo(repo_path)
        pr = repo.get_pull(pr_number)
        
        # æ£€æŸ¥ PR æ˜¯å¦å¯åˆå¹¶
        if not pr.mergeable:
            return {
                "error": "PR ä¸å¯åˆå¹¶",
                "mergeable_state": pr.mergeable_state,
                "status": pr.raw_data.get('status', 'unknown')
            }
        
        # æ£€æŸ¥æ˜¯å¦æœ‰åˆå¹¶å†²çª
        if pr.mergeable_state == "dirty":
            return {"error": "PR æœ‰åˆå¹¶å†²çªï¼Œæ— æ³•è‡ªåŠ¨åˆå¹¶"}
        
        # æ£€æŸ¥æ˜¯å¦éœ€è¦ CI é€šè¿‡
        if pr.mergeable_state == "blocked":
            # è·å–çŠ¶æ€æ£€æŸ¥
            status_checks = []
            try:
                for commit in pr.get_commits():
                    for status in commit.get_status().statuses:
                        status_checks.append({
                            "context": status.context,
                            "state": status.state,
                            "description": status.description,
                            "target_url": status.target_url
                        })
            except Exception:
                pass
            
            return {
                "error": "PR è¢«é˜»æ­¢åˆå¹¶ï¼Œå¯èƒ½éœ€è¦ CI æ£€æŸ¥é€šè¿‡æˆ–å®¡æŸ¥æ‰¹å‡†",
                "status_checks": status_checks
            }
        
        # æ‰§è¡Œåˆå¹¶
        print(f"[DEBUG] å¼€å§‹æ‰§è¡Œåˆå¹¶æ“ä½œ...")
        try:
            print(f"[DEBUG] ä½¿ç”¨åˆå¹¶æ–¹æ³•: {merge_method}")
            print(f"[DEBUG] æäº¤ä¿¡æ¯: {commit_message}")
            if commit_title:
                print(f"[DEBUG] æäº¤æ ‡é¢˜: {commit_title}")
            
            merge_result = pr.merge(
                commit_message=commit_message,
                commit_title=commit_title,
                merge_method=merge_method
            )
            
            print(f"[DEBUG] åˆå¹¶æ“ä½œæˆåŠŸå®Œæˆ")
            print(f"[DEBUG] merge_result.merged: {merge_result.merged}")
            print(f"[DEBUG] merge_result.sha: {merge_result.sha}")
            print(f"[DEBUG] merge_result.message: {merge_result.message}")
            
            return {
                "status": "success",
                "merged": merge_result.merged,
                "sha": merge_result.sha,
                "message": merge_result.message,
                "pr_number": pr_number,
                "merge_method": merge_method,
                "merged_at": merge_result.merged_at.isoformat() if hasattr(merge_result, "merged_at") and merge_result.merged_at else None,
                "token_used": token_env
            }
            
        except Exception as e:
            print(f"[DEBUG] åˆå¹¶æ“ä½œå‘ç”Ÿå¼‚å¸¸")
            print(f"[DEBUG] å¼‚å¸¸å¯¹è±¡: {e}")
            print(f"[DEBUG] å¼‚å¸¸ç±»å‹: {type(e).__name__}")
            print(f"[DEBUG] å¼‚å¸¸repr: {repr(e)}")
            print(f"[DEBUG] å¼‚å¸¸args: {getattr(e, 'args', 'No args')}")
            
            # å°è¯•è·å–æ›´è¯¦ç»†çš„é”™è¯¯ä¿¡æ¯
            error_msg = None
            try:
                error_msg = str(e)
                print(f"[DEBUG] str(e) = {error_msg}")
            except Exception as str_err:
                print(f"[DEBUG] str(e) ä¹Ÿå¤±è´¥: {str_err}")
                error_msg = f"å¼‚å¸¸æ— æ³•è½¬æ¢ä¸ºå­—ç¬¦ä¸² (ç±»å‹: {type(e).__name__})"
            
            # æ£€æŸ¥æ˜¯å¦æœ‰ PyGithub ç‰¹æœ‰çš„å±æ€§
            if hasattr(e, 'data'):
                print(f"[DEBUG] å¼‚å¸¸data: {e.data}")
            if hasattr(e, 'status'):
                print(f"[DEBUG] å¼‚å¸¸status: {e.status}")
            if hasattr(e, 'headers'):
                print(f"[DEBUG] å¼‚å¸¸headers: {e.headers}")
            
            # æä¾›æ›´è¯¦ç»†çš„é”™è¯¯ä¿¡æ¯
            if error_msg and "Required status check" in error_msg:
                print(f"[DEBUG] è¯†åˆ«é”™è¯¯: å¿…éœ€çš„çŠ¶æ€æ£€æŸ¥æœªé€šè¿‡")
                return {"error": "åˆå¹¶å¤±è´¥ï¼šå¿…éœ€çš„çŠ¶æ€æ£€æŸ¥æœªé€šè¿‡"}
            elif error_msg and "Review required" in error_msg:
                print(f"[DEBUG] è¯†åˆ«é”™è¯¯: éœ€è¦ä»£ç å®¡æŸ¥")
                return {"error": "åˆå¹¶å¤±è´¥ï¼šéœ€è¦ä»£ç å®¡æŸ¥"}
            elif error_msg and "not authorized" in error_msg.lower():
                print(f"[DEBUG] è¯†åˆ«é”™è¯¯: æ²¡æœ‰æƒé™")
                return {"error": "åˆå¹¶å¤±è´¥ï¼šæ²¡æœ‰æƒé™åˆå¹¶æ­¤ PR"}
            elif error_msg and "merge conflict" in error_msg.lower():
                print(f"[DEBUG] è¯†åˆ«é”™è¯¯: åˆå¹¶å†²çª")
                return {"error": "åˆå¹¶å¤±è´¥ï¼šå­˜åœ¨åˆå¹¶å†²çª"}
            else:
                print(f"[DEBUG] æœªè¯†åˆ«çš„é”™è¯¯ç±»å‹ï¼Œæ„é€ è¯¦ç»†é”™è¯¯ä¿¡æ¯")
                detailed_error = f"åˆå¹¶å¤±è´¥: {error_msg if error_msg else 'æœªçŸ¥é”™è¯¯'} (ç±»å‹: {type(e).__name__})"
                return {"error": detailed_error}
        
    except Exception as e:
        print(f"[DEBUG] å¤–å±‚å¼‚å¸¸æ•è·")
        print(f"[DEBUG] å¤–å±‚å¼‚å¸¸å¯¹è±¡: {e}")
        print(f"[DEBUG] å¤–å±‚å¼‚å¸¸ç±»å‹: {type(e).__name__}")
        print(f"[DEBUG] å¤–å±‚å¼‚å¸¸repr: {repr(e)}")
        
        # å°è¯•å®‰å…¨åœ°è·å–é”™è¯¯ä¿¡æ¯
        error_msg = "æœªçŸ¥å¤–å±‚å¼‚å¸¸"
        try:
            error_msg = str(e)
        except Exception:
            error_msg = f"å¤–å±‚å¼‚å¸¸æ— æ³•è½¬æ¢ä¸ºå­—ç¬¦ä¸² (ç±»å‹: {type(e).__name__})"
        
        return {"error": f"åˆå¹¶ PR å¤±è´¥: {error_msg}"}

def check_pr_author(repo_path: str, pr_number: int, token_env: str = "GITHUB_TOKEN") -> dict:
    """
    æ£€æŸ¥ PR çš„åˆ›å»ºè€…ä¿¡æ¯
    
    Args:
        repo_path: ä»“åº“è·¯å¾„ï¼Œæ ¼å¼ä¸º "owner/repo"
        pr_number: PR ç¼–å·
        token_env: GitHub Token ç¯å¢ƒå˜é‡åï¼ˆé»˜è®¤ "GITHUB_TOKEN"ï¼‰
    
    Returns:
        dict: åŒ…å« PR ä½œè€…ä¿¡æ¯å’Œå½“å‰ç”¨æˆ·ä¿¡æ¯
    """
    try:
        # å‚æ•°éªŒè¯
        if not repo_path or not isinstance(repo_path, str):
            return {"error": "repo_path å¿…é¡»æ˜¯æœ‰æ•ˆçš„å­—ç¬¦ä¸²ï¼Œæ ¼å¼ä¸º 'owner/repo'"}
        
        if not pr_number or not isinstance(pr_number, int):
            return {"error": "pr_number å¿…é¡»æ˜¯æœ‰æ•ˆçš„æ•´æ•°"}
        
        if not token_env or not isinstance(token_env, str):
            return {"error": "token_env å¿…é¡»æ˜¯æœ‰æ•ˆçš„å­—ç¬¦ä¸²"}
        
        token = os.getenv(token_env)
        if not token:
            return {"error": f"éœ€è¦è®¾ç½® {token_env} ç¯å¢ƒå˜é‡"}
        
        g = Github(token)
        repo = g.get_repo(repo_path)
        pr = repo.get_pull(pr_number)
        
        # è·å–å½“å‰ç”¨æˆ·ä¿¡æ¯
        current_user = g.get_user()
        
        # æ£€æŸ¥æ˜¯å¦æ˜¯è‡ªå·±çš„PR
        is_own_pr = pr.user.login == current_user.login
        
        return {
            "status": "success",
            "pr_number": pr_number,
            "pr_author": pr.user.login,
            "current_user": current_user.login,
            "is_own_pr": is_own_pr,
            "pr_title": pr.title,
            "pr_state": pr.state,
            "can_approve": not is_own_pr,
            "token_used": token_env,
            "message": "è¿™æ˜¯æ‚¨è‡ªå·±çš„PRï¼Œæ— æ³•è‡ªå·±æ‰¹å‡†" if is_own_pr else "å¯ä»¥æ‰¹å‡†æ­¤PR"
        }
        
    except Exception as e:
        return {"error": f"æ£€æŸ¥ PR ä½œè€…å¤±è´¥: {str(e)}"}

def request_pr_review(repo_path: str, pr_number: int, reviewers: str = None, team_reviewers: str = None, token_env: str = "GITHUB_TOKEN") -> dict:
    """
    è¯·æ±‚å…¶ä»–ç”¨æˆ·å®¡æŸ¥ PR
    
    Args:
        repo_path: ä»“åº“è·¯å¾„ï¼Œæ ¼å¼ä¸º "owner/repo"
        pr_number: PR ç¼–å·
        reviewers: å®¡æŸ¥è€…ç”¨æˆ·ååˆ—è¡¨ (JSON å­—ç¬¦ä¸²)ï¼ˆå¯é€‰ï¼‰
        team_reviewers: å›¢é˜Ÿå®¡æŸ¥è€…åˆ—è¡¨ (JSON å­—ç¬¦ä¸²)ï¼ˆå¯é€‰ï¼‰
        token_env: GitHub Token ç¯å¢ƒå˜é‡åï¼ˆé»˜è®¤ "GITHUB_TOKEN"ï¼‰
    
    Returns:
        dict: åŒ…å«è¯·æ±‚ç»“æœæˆ–é”™è¯¯ä¿¡æ¯
    """
    try:
        if reviewers and isinstance(reviewers, str):
            reviewers = json.loads(reviewers)
        if team_reviewers and isinstance(team_reviewers, str):
            team_reviewers = json.loads(team_reviewers)
        token = os.getenv(token_env)
        if not token:
            return {"error": f"éœ€è¦è®¾ç½® {token_env} ç¯å¢ƒå˜é‡"}
        
        g = Github(token)
        repo = g.get_repo(repo_path)
        pr = repo.get_pull(pr_number)
        
        # æ£€æŸ¥æ˜¯å¦æ˜¯è‡ªå·±çš„PR
        current_user = g.get_user()
        is_own_pr = pr.user.login == current_user.login
        
        if not is_own_pr:
            return {"error": "åªèƒ½è¯·æ±‚å®¡æŸ¥è‡ªå·±çš„PR"}
        
        # å¦‚æœæ²¡æœ‰æŒ‡å®šå®¡æŸ¥è€…ï¼Œå°è¯•è·å–ä»“åº“çš„è´¡çŒ®è€…
        if not reviewers and not team_reviewers:
            try:
                contributors = [contributor.login for contributor in repo.get_contributors()]
                # æ’é™¤è‡ªå·±
                contributors = [user for user in contributors if user != current_user.login]
                if contributors:
                    reviewers = contributors[:3]  # æœ€å¤šè¯·æ±‚3ä¸ªå®¡æŸ¥è€…
            except Exception:
                pass
        
        if not reviewers and not team_reviewers:
            return {"error": "æ²¡æœ‰å¯ç”¨çš„å®¡æŸ¥è€…ï¼Œè¯·æ‰‹åŠ¨æŒ‡å®š reviewers æˆ– team_reviewers å‚æ•°"}
        
        # åˆ›å»ºå®¡æŸ¥è¯·æ±‚
        try:
            pr.create_review_request(reviewers=reviewers, team_reviewers=team_reviewers)
            
            return {
                "status": "success",
                "pr_number": pr_number,
                "requested_reviewers": reviewers or [],
                "requested_team_reviewers": team_reviewers or [],
                "token_used": token_env,
                "message": f"å·²è¯·æ±‚å®¡æŸ¥ PR #{pr_number}"
            }
            
        except Exception as e:
            error_msg = str(e)
            if "Review cannot be requested" in error_msg:
                return {"error": "æ— æ³•è¯·æ±‚å®¡æŸ¥ï¼Œå¯èƒ½æ˜¯å› ä¸ºPRä½œè€…æ²¡æœ‰æƒé™æˆ–å®¡æŸ¥è€…ä¸å¯ç”¨"}
            else:
                return {"error": f"è¯·æ±‚å®¡æŸ¥å¤±è´¥: {error_msg}"}
        
    except Exception as e:
        return {"error": f"è¯·æ±‚ PR å®¡æŸ¥å¤±è´¥: {str(e)}"}

def list_prs(
    repo_path: str,
    state: str = "open",
    sort: str = "created",
    direction: str = "desc",
    limit: int = 20,
    token_env: str = "GITHUB_TOKEN"
) -> dict:
    """
    åˆ—å‡ºä»“åº“çš„ PR
    
    Args:
        repo_path: ä»“åº“è·¯å¾„ï¼Œæ ¼å¼ä¸º "owner/repo"
        state: PR çŠ¶æ€ï¼Œå¯é€‰ "open", "closed", "all"ï¼ˆé»˜è®¤ "open"ï¼‰
        sort: æ’åºæ–¹å¼ï¼Œå¯é€‰ "created", "updated", "popularity"ï¼ˆé»˜è®¤ "created"ï¼‰
        direction: æ’åºæ–¹å‘ï¼Œå¯é€‰ "asc", "desc"ï¼ˆé»˜è®¤ "desc"ï¼‰
        limit: æœ€å¤§è¿”å›æ•°é‡ï¼ˆé»˜è®¤ 20ï¼‰
        token_env: GitHub Token ç¯å¢ƒå˜é‡åï¼ˆé»˜è®¤ "GITHUB_TOKEN"ï¼‰
    
    Returns:
        dict: åŒ…å« PR åˆ—è¡¨æˆ–é”™è¯¯ä¿¡æ¯
    """
    try:
        token = os.getenv(token_env)
        g = Github(token) if token else Github()
        repo = g.get_repo(repo_path)
        
        # è·å– PR åˆ—è¡¨
        pulls = repo.get_pulls(state=state, sort=sort, direction=direction)
        
        pr_list = []
        count = 0
        for pr in pulls:
            if count >= limit:
                break
                
            pr_info = {
                "number": pr.number,
                "title": pr.title,
                "body": pr.body[:200] + "..." if pr.body and len(pr.body) > 200 else pr.body,
                "state": pr.state,
                "head_branch": pr.head.ref,
                "base_branch": pr.base.ref,
                "author": pr.user.login,
                "created_at": pr.created_at.isoformat(),
                "updated_at": pr.updated_at.isoformat(),
                "mergeable": pr.mergeable,
                "mergeable_state": pr.mergeable_state,
                "commits": pr.commits,
                "additions": pr.additions,
                "deletions": pr.deletions,
                "changed_files": pr.changed_files,
                "url": pr.html_url
            }
            
            # è·å–å®¡æŸ¥çŠ¶æ€
            try:
                reviews = pr.get_reviews()
                approvals = sum(1 for review in reviews if review.state == "APPROVED")
                changes_requested = sum(1 for review in reviews if review.state == "CHANGES_REQUESTED")
                
                pr_info["review_status"] = {
                    "approvals": approvals,
                    "changes_requested": changes_requested,
                    "total_reviews": reviews.totalCount
                }
            except Exception:
                pr_info["review_status"] = {"approvals": 0, "changes_requested": 0, "total_reviews": 0}
            
            pr_list.append(pr_info)
            count += 1
        
        return {
            "status": "success",
            "repo": repo_path,
            "state": state,
            "total_prs": len(pr_list),
            "prs": pr_list,
            "token_used": token_env
        }
        
    except Exception as e:
        return {"error": f"è·å– PR åˆ—è¡¨å¤±è´¥: {str(e)}"}

def smart_review_pr(
    repo_path: str,
    pr_number: int,
    auto_merge: bool = True,
    merge_method: str = "merge",
    token_env: str = "GITHUB_TOKEN"
) -> dict:
    """
    æ™ºèƒ½ PR å®¡æŸ¥å·¥å…· - è‡ªåŠ¨å®¡æŸ¥ PR å¹¶å†³å®šæ˜¯å¦åˆå¹¶æˆ–æå‡ºä¿®æ”¹å»ºè®®
    
    Args:
        repo_path: ä»“åº“è·¯å¾„ï¼Œæ ¼å¼ä¸º "owner/repo"
        pr_number: PR ç¼–å·
        auto_merge: æ˜¯å¦åœ¨å®¡æŸ¥é€šè¿‡åè‡ªåŠ¨åˆå¹¶ï¼ˆé»˜è®¤ Trueï¼‰
        merge_method: åˆå¹¶æ–¹æ³•ï¼Œå¯é€‰ "merge", "squash", "rebase"ï¼ˆé»˜è®¤ "merge"ï¼‰
        token_env: GitHub Token ç¯å¢ƒå˜é‡åï¼ˆé»˜è®¤ "GITHUB_TOKEN"ï¼‰
    
    Returns:
        dict: åŒ…å«å®¡æŸ¥ç»“æœå’Œæ‰§è¡Œæ“ä½œçš„è¯¦ç»†ä¿¡æ¯
    """
    try:
        # å‚æ•°éªŒè¯
        if not repo_path or not isinstance(repo_path, str):
            return {"error": "repo_path å¿…é¡»æ˜¯æœ‰æ•ˆçš„å­—ç¬¦ä¸²ï¼Œæ ¼å¼ä¸º 'owner/repo'"}
        
        if not pr_number or not isinstance(pr_number, int):
            return {"error": "pr_number å¿…é¡»æ˜¯æœ‰æ•ˆçš„æ•´æ•°"}
        
        if not token_env or not isinstance(token_env, str):
            return {"error": "token_env å¿…é¡»æ˜¯æœ‰æ•ˆçš„å­—ç¬¦ä¸²"}
        
        if merge_method not in ["merge", "squash", "rebase"]:
            return {"error": "merge_method å¿…é¡»æ˜¯ 'merge', 'squash', æˆ– 'rebase'"}
        
        # é¦–å…ˆæ£€æŸ¥ PR ä½œè€…ä¿¡æ¯
        author_check = check_pr_author(repo_path, pr_number, token_env)
        if "error" in author_check:
            return author_check
        
        # è·å– PR è¯¦ç»†ä¿¡æ¯è¿›è¡Œå®¡æŸ¥
        token = os.getenv(token_env)
        if not token:
            return {"error": f"éœ€è¦è®¾ç½® {token_env} ç¯å¢ƒå˜é‡"}
        
        g = Github(token)
        repo = g.get_repo(repo_path)
        pr = repo.get_pull(pr_number)
        
        # æ”¶é›† PR ä¿¡æ¯ç”¨äºå®¡æŸ¥
        files_info = []
        total_additions = 0
        total_deletions = 0
        
        for file in pr.get_files():
            file_info = {
                "filename": file.filename,
                "status": file.status,
                "additions": file.additions,
                "deletions": file.deletions,
                "changes": file.changes,
                "patch": file.patch[:2000] + "..." if len(file.patch) > 2000 else file.patch
            }
            files_info.append(file_info)
            total_additions += file.additions
            total_deletions += file.deletions
        
        # æ„å»º PR æ‘˜è¦
        pr_summary = {
            "number": pr.number,
            "title": pr.title,
            "body": pr.body,
            "author": pr.user.login,
            "state": pr.state,
            "head_branch": pr.head.ref,
            "base_branch": pr.base.ref,
            "mergeable": pr.mergeable,
            "mergeable_state": pr.mergeable_state,
            "commits": pr.commits,
            "additions": total_additions,
            "deletions": total_deletions,
            "changed_files": pr.changed_files,
            "files": files_info,
            "is_own_pr": author_check["is_own_pr"]
        }
        
        # æ‰§è¡Œæ™ºèƒ½å®¡æŸ¥é€»è¾‘
        review_result = _perform_intelligent_review(json.dumps(pr_summary), repo)
        
        # æ ¹æ®å®¡æŸ¥ç»“æœæ‰§è¡Œç›¸åº”æ“ä½œ
        if review_result["decision"] == "approve_and_merge" and auto_merge:
            # å°è¯•åˆå¹¶ PR
            merge_result = merge_pr(
                repo_path=repo_path,
                pr_number=pr_number,
                merge_method=merge_method,
                commit_title=f"Merge PR #{pr_number}: {pr.title}",
                commit_message=f"Auto-merged after review: {review_result['summary']}",
                token_env=token_env
            )
            
            if merge_result.get("status") == "success":
                return {
                    "status": "success",
                    "action": "approved_and_merged",
                    "pr_number": pr_number,
                    "review_summary": review_result,
                    "merge_result": merge_result,
                    "token_used": token_env,
                    "message": f"PR #{pr_number} å·²é€šè¿‡å®¡æŸ¥å¹¶è‡ªåŠ¨åˆå¹¶"
                }
            else:
                # åˆå¹¶å¤±è´¥ï¼Œæ·»åŠ å®¡æŸ¥è¯„è®ºä½†ä¸åˆå¹¶
                comment = f"âœ… å®¡æŸ¥é€šè¿‡ï¼Œä½†è‡ªåŠ¨åˆå¹¶å¤±è´¥ï¼š{merge_result.get('error', 'æœªçŸ¥é”™è¯¯')}\n\n{review_result['summary']}"
                review_result = review_pr(repo_path, pr_number, approve=False, review_comment=comment, token_env=token_env)
                return {
                    "status": "partial_success",
                    "action": "approved_but_merge_failed",
                    "pr_number": pr_number,
                    "review_summary": review_result,
                    "merge_error": merge_result.get("error"),
                    "message": f"PR #{pr_number} å®¡æŸ¥é€šè¿‡ä½†åˆå¹¶å¤±è´¥ï¼Œå·²æ·»åŠ è¯„è®º"
                }
        
        elif review_result["decision"] == "request_changes":
            # è¦æ±‚ä¿®æ”¹ï¼Œæ·»åŠ è¯¦ç»†è¯„è®º
            comment = f"âŒ éœ€è¦ä¿®æ”¹\n\n{review_result['summary']}\n\n**ä¿®æ”¹å»ºè®®ï¼š**\n{review_result['suggestions']}"
            review_result = review_pr(repo_path, pr_number, approve=False, review_comment=comment, token_env=token_env)
            return {
                "status": "changes_requested",
                "action": "requested_changes",
                "pr_number": pr_number,
                "review_summary": review_result,
                "review_result": review_result,
                "message": f"PR #{pr_number} éœ€è¦ä¿®æ”¹ï¼Œå·²æ·»åŠ è¯¦ç»†è¯„è®º"
            }
        
        elif review_result["decision"] == "request_human_review":
            # è¯·æ±‚äººå·¥å®¡æŸ¥
            if pr_summary["is_own_pr"]:
                # å¦‚æœæ˜¯è‡ªå·±çš„PRï¼Œè¯·æ±‚å…¶ä»–ç”¨æˆ·å®¡æŸ¥
                request_result = request_pr_review(repo_path, pr_number, token_env=token_env)
                comment = f"ğŸ¤” éœ€è¦äººå·¥å®¡æŸ¥\n\n{review_result['summary']}\n\nå·²è¯·æ±‚å…¶ä»–ç”¨æˆ·ååŠ©å®¡æŸ¥ã€‚"
            else:
                # å¦‚æœä¸æ˜¯è‡ªå·±çš„PRï¼Œæ·»åŠ è¯„è®ºè¯·æ±‚æ›´å¤šå®¡æŸ¥
                comment = f"ğŸ¤” éœ€è¦è¿›ä¸€æ­¥å®¡æŸ¥\n\n{review_result['summary']}\n\nå»ºè®®è¯·æ±‚å…¶ä»–ç»´æŠ¤è€…å‚ä¸å®¡æŸ¥ã€‚"
                request_result = {"status": "commented"}
            
            review_result = review_pr(repo_path, pr_number, approve=False, review_comment=comment, token_env=token_env)
            return {
                "status": "human_review_requested",
                "action": "requested_human_review",
                "pr_number": pr_number,
                "review_summary": review_result,
                "request_result": request_result,
                "review_result": review_result,
                "message": f"PR #{pr_number} éœ€è¦äººå·¥å®¡æŸ¥ï¼Œå·²å¤„ç†"
            }
        
        else:
            return {
                "status": "review_completed",
                "action": "review_only",
                "pr_number": pr_number,
                "review_summary": review_result,
                "message": f"PR #{pr_number} å®¡æŸ¥å®Œæˆ"
            }
            
    except Exception as e:
        return {"error": f"æ™ºèƒ½å®¡æŸ¥å¤±è´¥: {str(e)}"}

def review_pr_with_review_token(
    repo_path: str,
    pr_number: int,
    approve: bool = False,
    review_comment: str = None
) -> dict:
    """
    ä½¿ç”¨å®¡æŸ¥ä¸“ç”¨Tokençš„ PR å®¡æŸ¥å·¥å…·
    
    Args:
        repo_path: ä»“åº“è·¯å¾„ï¼Œæ ¼å¼ä¸º "owner/repo"
        pr_number: PR ç¼–å·
        approve: æ˜¯å¦æ‰¹å‡† PRï¼ˆé»˜è®¤ Falseï¼‰
        review_comment: å®¡æŸ¥è¯„è®ºï¼ˆå¯é€‰ï¼‰
    
    Returns:
        dict: åŒ…å«å®¡æŸ¥ç»“æœæˆ–é”™è¯¯ä¿¡æ¯
    """
    try:
        # å‚æ•°éªŒè¯
        if not repo_path or not isinstance(repo_path, str):
            return {"error": "repo_path å¿…é¡»æ˜¯æœ‰æ•ˆçš„å­—ç¬¦ä¸²ï¼Œæ ¼å¼ä¸º 'owner/repo'"}
        
        if not pr_number or not isinstance(pr_number, int):
            return {"error": "pr_number å¿…é¡»æ˜¯æœ‰æ•ˆçš„æ•´æ•°"}
        
        # ä½¿ç”¨å®¡æŸ¥ä¸“ç”¨Token
        token_env = "REVIEW_GITHUB_TOKEN"
        token = os.getenv(token_env)
        if not token:
            return {"error": f"éœ€è¦è®¾ç½® {token_env} ç¯å¢ƒå˜é‡"}
        
        g = Github(token)
        repo = g.get_repo(repo_path)
        pr = repo.get_pull(pr_number)
        
        # æ£€æŸ¥æ˜¯å¦æ˜¯è‡ªå·±çš„PR
        current_user = g.get_user()
        is_own_pr = pr.user.login == current_user.login
        
        if is_own_pr and approve:
            return {
                "error": "æ— æ³•æ‰¹å‡†è‡ªå·±çš„PR",
                "pr_author": pr.user.login,
                "current_user": current_user.login,
                "token_used": token_env,
                "suggestion": "æ‚¨å¯ä»¥ï¼š1) ä½¿ç”¨ request_pr_review è¯·æ±‚å…¶ä»–ç”¨æˆ·å®¡æŸ¥ï¼Œ2) åªæ·»åŠ è¯„è®ºè€Œä¸æ‰¹å‡†",
                "can_comment": True
            }
        
        # è·å– PR æ–‡ä»¶å˜æ›´
        files_changed = []
        for file in pr.get_files():
            files_changed.append({
                "filename": file.filename,
                "status": file.status,
                "additions": file.additions,
                "deletions": file.deletions,
                "changes": file.changes,
                "patch": file.patch[:1000] + "..." if len(file.patch) > 1000 else file.patch
            })
        
        # è·å– PR è¯¦æƒ…
        pr_details = {
            "number": pr.number,
            "title": pr.title,
            "body": pr.body,
            "state": pr.state,
            "head_branch": pr.head.ref,
            "base_branch": pr.base.ref,
            "author": pr.user.login,
            "created_at": pr.created_at.isoformat(),
            "updated_at": pr.updated_at.isoformat(),
            "mergeable": pr.mergeable,
            "mergeable_state": pr.mergeable_state,
            "files_changed": files_changed,
            "commits": pr.commits,
            "additions": pr.additions,
            "deletions": pr.deletions,
            "changed_files": pr.changed_files
        }
        
        # å¦‚æœéœ€è¦æ‰¹å‡†æˆ–æ·»åŠ è¯„è®º
        if approve or review_comment:
            try:
                # åˆ›å»ºå®¡æŸ¥
                if approve:
                    pr.create_review(
                        body=review_comment or "LGTM! Approved by ADK Companion.",
                        event="APPROVE"
                    )
                    pr_details["review_action"] = "approved"
                elif review_comment:
                    pr.create_review(
                        body=review_comment,
                        event="COMMENT"
                    )
                    pr_details["review_action"] = "commented"
                    
            except Exception as e:
                return {"error": f"åˆ›å»ºå®¡æŸ¥å¤±è´¥: {str(e)}"}
        
        return {
            "status": "success",
            "pr_details": pr_details,
            "token_used": token_env,
            "message": f"Successfully reviewed PR #{pr_number}"
        }
        
    except Exception as e:
        return {"error": f"å®¡æŸ¥ PR å¤±è´¥: {str(e)}"}

def merge_pr_with_review_token(
    repo_path: str,
    pr_number: int,
    merge_method: str = "merge",
    commit_title: str = None,
    commit_message: str = None
) -> dict:
    """
    ä½¿ç”¨å®¡æŸ¥ä¸“ç”¨Tokençš„ PR åˆå¹¶å·¥å…·
    
    Args:
        repo_path: ä»“åº“è·¯å¾„ï¼Œæ ¼å¼ä¸º "owner/repo"
        pr_number: PR ç¼–å·
        merge_method: åˆå¹¶æ–¹æ³•ï¼Œå¯é€‰ "merge", "squash", "rebase"ï¼ˆé»˜è®¤ "merge"ï¼‰
        commit_title: åˆå¹¶æäº¤æ ‡é¢˜ï¼ˆå¯é€‰ï¼‰
        commit_message: åˆå¹¶æäº¤æ¶ˆæ¯ï¼ˆå¯é€‰ï¼‰
    
    Returns:
        dict: åŒ…å«åˆå¹¶ç»“æœæˆ–é”™è¯¯ä¿¡æ¯
    """
    try:
        # å‚æ•°éªŒè¯
        if not repo_path or not isinstance(repo_path, str):
            return {"error": "repo_path å¿…é¡»æ˜¯æœ‰æ•ˆçš„å­—ç¬¦ä¸²ï¼Œæ ¼å¼ä¸º 'owner/repo'"}
        
        if not pr_number or not isinstance(pr_number, int):
            return {"error": "pr_number å¿…é¡»æ˜¯æœ‰æ•ˆçš„æ•´æ•°"}
        
        if merge_method not in ["merge", "squash", "rebase"]:
            return {"error": "merge_method å¿…é¡»æ˜¯ 'merge', 'squash', æˆ– 'rebase'"}
        
        # ä½¿ç”¨å®¡æŸ¥ä¸“ç”¨Token
        token_env = "REVIEW_GITHUB_TOKEN"
        token = os.getenv(token_env)
        if not token:
            return {"error": f"éœ€è¦è®¾ç½® {token_env} ç¯å¢ƒå˜é‡"}
        
        g = Github(token)
        repo = g.get_repo(repo_path)
        pr = repo.get_pull(pr_number)
        
        # æ£€æŸ¥ PR æ˜¯å¦å¯åˆå¹¶
        if not pr.mergeable:
            return {
                "error": "PR ä¸å¯åˆå¹¶",
                "mergeable_state": pr.mergeable_state,
                "status": pr.raw_data.get('status', 'unknown')
            }
        
        # æ£€æŸ¥æ˜¯å¦æœ‰åˆå¹¶å†²çª
        if pr.mergeable_state == "dirty":
            return {"error": "PR æœ‰åˆå¹¶å†²çªï¼Œæ— æ³•è‡ªåŠ¨åˆå¹¶"}
        
        # æ£€æŸ¥æ˜¯å¦éœ€è¦ CI é€šè¿‡
        if pr.mergeable_state == "blocked":
            # è·å–çŠ¶æ€æ£€æŸ¥
            status_checks = []
            try:
                for commit in pr.get_commits():
                    for status in commit.get_status().statuses:
                        status_checks.append({
                            "context": status.context,
                            "state": status.state,
                            "description": status.description,
                            "target_url": status.target_url
                        })
            except Exception:
                pass
            
            return {
                "error": "PR è¢«é˜»æ­¢åˆå¹¶ï¼Œå¯èƒ½éœ€è¦ CI æ£€æŸ¥é€šè¿‡æˆ–å®¡æŸ¥æ‰¹å‡†",
                "status_checks": status_checks
            }
        
        try:
            # ç¡®ä¿å‚æ•°æ ¼å¼æ­£ç¡®
            if not commit_message:
                commit_message = f"Merge PR #{pr_number}"
            
            if not commit_title:
                commit_title = f"Merge pull request #{pr_number} from {pr.head.ref}"
            
            merge_result = pr.merge(
                commit_message=commit_message,
                commit_title=commit_title,
                merge_method=merge_method
            )
            
            return {
                "status": "success",
                "merged": merge_result.merged,
                "sha": merge_result.sha,
                "message": merge_result.message,
                "pr_number": pr_number,
                "merge_method": merge_method,
                "merged_at": merge_result.merged_at.isoformat() if hasattr(merge_result, "merged_at") and merge_result.merged_at else None,
                "token_used": token_env
            }
            
        except Exception as e:
            error_msg = str(e) if e else "æœªçŸ¥é”™è¯¯"
            if not error_msg or error_msg == "None":
                error_msg = "åˆå¹¶å¤±è´¥ï¼Œå¯èƒ½æ˜¯å‚æ•°é”™è¯¯æˆ–æƒé™é—®é¢˜"
            
            # æä¾›æ›´è¯¦ç»†çš„é”™è¯¯ä¿¡æ¯
            if "Required status check" in error_msg:
                return {"error": "åˆå¹¶å¤±è´¥ï¼šå¿…éœ€çš„çŠ¶æ€æ£€æŸ¥æœªé€šè¿‡"}
            elif "Review required" in error_msg:
                return {"error": "åˆå¹¶å¤±è´¥ï¼šéœ€è¦ä»£ç å®¡æŸ¥"}
            elif "not authorized" in error_msg.lower():
                return {"error": "åˆå¹¶å¤±è´¥ï¼šæ²¡æœ‰æƒé™åˆå¹¶æ­¤ PR"}
            elif "merge conflict" in error_msg.lower():
                return {"error": "åˆå¹¶å¤±è´¥ï¼šå­˜åœ¨åˆå¹¶å†²çª"}
            elif "Base branch was modified" in error_msg:
                return {"error": "åˆå¹¶å¤±è´¥ï¼šåŸºç¡€åˆ†æ”¯å·²è¢«ä¿®æ”¹ï¼Œè¯·æ›´æ–°PR"}
            elif "Pull Request is not mergeable" in error_msg:
                return {"error": "åˆå¹¶å¤±è´¥ï¼šPRä¸å¯åˆå¹¶"}
            else:
                return {"error": f"åˆå¹¶å¤±è´¥: {error_msg}"}
        
    except Exception as e:
        # å¤–å±‚å¼‚å¸¸å¤„ç†
        error_msg = str(e) if e else "æœªçŸ¥é”™è¯¯"
        if not error_msg or error_msg == "None":
            error_msg = "åˆå¹¶PRæ“ä½œå¤±è´¥ï¼Œå¯èƒ½æ˜¯å‚æ•°é”™è¯¯æˆ–ç½‘ç»œé—®é¢˜"
        return {"error": f"åˆå¹¶ PR å¤±è´¥: {error_msg}"}

def check_pr_author_with_review_token(
    repo_path: str,
    pr_number: int
) -> dict:
    """
    ä½¿ç”¨å®¡æŸ¥ä¸“ç”¨Tokenæ£€æŸ¥ PR ä½œè€…ä¿¡æ¯
    
    Args:
        repo_path: ä»“åº“è·¯å¾„ï¼Œæ ¼å¼ä¸º "owner/repo"
        pr_number: PR ç¼–å·
    
    Returns:
        dict: åŒ…å« PR ä½œè€…ä¿¡æ¯å’Œå½“å‰ç”¨æˆ·ä¿¡æ¯
    """
    try:
        # å‚æ•°éªŒè¯
        if not repo_path or not isinstance(repo_path, str):
            return {"error": "repo_path å¿…é¡»æ˜¯æœ‰æ•ˆçš„å­—ç¬¦ä¸²ï¼Œæ ¼å¼ä¸º 'owner/repo'"}
        
        if not pr_number or not isinstance(pr_number, int):
            return {"error": "pr_number å¿…é¡»æ˜¯æœ‰æ•ˆçš„æ•´æ•°"}
        
        # ä½¿ç”¨å®¡æŸ¥ä¸“ç”¨Token
        token_env = "REVIEW_GITHUB_TOKEN"
        token = os.getenv(token_env)
        if not token:
            return {"error": f"éœ€è¦è®¾ç½® {token_env} ç¯å¢ƒå˜é‡"}
        
        g = Github(token)
        repo = g.get_repo(repo_path)
        pr = repo.get_pull(pr_number)
        
        # è·å–å½“å‰ç”¨æˆ·ä¿¡æ¯
        current_user = g.get_user()
        
        # æ£€æŸ¥æ˜¯å¦æ˜¯è‡ªå·±çš„PR
        is_own_pr = pr.user.login == current_user.login
        
        return {
            "status": "success",
            "pr_number": pr_number,
            "pr_author": pr.user.login,
            "current_user": current_user.login,
            "is_own_pr": is_own_pr,
            "pr_title": pr.title,
            "pr_state": pr.state,
            "can_approve": not is_own_pr,
            "token_used": token_env,
            "message": "è¿™æ˜¯æ‚¨è‡ªå·±çš„PRï¼Œæ— æ³•è‡ªå·±æ‰¹å‡†" if is_own_pr else "å¯ä»¥æ‰¹å‡†æ­¤PR"
        }
        
    except Exception as e:
        return {"error": f"æ£€æŸ¥ PR ä½œè€…å¤±è´¥: {str(e)}"}

def request_pr_review_with_review_token(
    repo_path: str,
    pr_number: int,
    reviewers: str = None,
    team_reviewers: str = None
) -> dict:
    """
    ä½¿ç”¨å®¡æŸ¥ä¸“ç”¨Tokenè¯·æ±‚å…¶ä»–ç”¨æˆ·å®¡æŸ¥ PR
    
    Args:
        repo_path: ä»“åº“è·¯å¾„ï¼Œæ ¼å¼ä¸º "owner/repo"
        pr_number: PR ç¼–å·
        reviewers: å®¡æŸ¥è€…ç”¨æˆ·ååˆ—è¡¨ (JSON å­—ç¬¦ä¸²)ï¼ˆå¯é€‰ï¼‰
        team_reviewers: å›¢é˜Ÿå®¡æŸ¥è€…åˆ—è¡¨ (JSON å­—ç¬¦ä¸²)ï¼ˆå¯é€‰ï¼‰
    
    Returns:
        dict: åŒ…å«è¯·æ±‚ç»“æœæˆ–é”™è¯¯ä¿¡æ¯
    """
    return request_pr_review(
        repo_path=repo_path,
        pr_number=pr_number,
        reviewers=reviewers,
        team_reviewers=team_reviewers,
        token_env="REVIEW_GITHUB_TOKEN"
    )

def list_prs_with_review_token(
    repo_path: str,
    state: str = "open",
    sort: str = "created",
    direction: str = "desc",
    limit: int = 20
) -> dict:
    """
    ä½¿ç”¨å®¡æŸ¥ä¸“ç”¨Tokenåˆ—å‡ºä»“åº“çš„ PR
    
    Args:
        repo_path: ä»“åº“è·¯å¾„ï¼Œæ ¼å¼ä¸º "owner/repo"
        state: PR çŠ¶æ€ï¼Œå¯é€‰ "open", "closed", "all"ï¼ˆé»˜è®¤ "open"ï¼‰
        sort: æ’åºæ–¹å¼ï¼Œå¯é€‰ "created", "updated", "popularity"ï¼ˆé»˜è®¤ "created"ï¼‰
        direction: æ’åºæ–¹å‘ï¼Œå¯é€‰ "asc", "desc"ï¼ˆé»˜è®¤ "desc"ï¼‰
        limit: æœ€å¤§è¿”å›æ•°é‡ï¼ˆé»˜è®¤ 20ï¼‰
    
    Returns:
        dict: åŒ…å« PR åˆ—è¡¨æˆ–é”™è¯¯ä¿¡æ¯
    """
    return list_prs(
        repo_path=repo_path,
        state=state,
        sort=sort,
        direction=direction,
        limit=limit,
        token_env="REVIEW_GITHUB_TOKEN"
    )

def _perform_intelligent_review(pr_summary_json: str, repo) -> dict:
    """
    æ‰§è¡Œæ™ºèƒ½å®¡æŸ¥é€»è¾‘
    
    Args:
        pr_summary_json: PR æ‘˜è¦ä¿¡æ¯ (JSON å­—ç¬¦ä¸²)
        repo: GitHub ä»“åº“å¯¹è±¡
    
    Returns:
        dict: å®¡æŸ¥ç»“æœ
    """
    pr_summary = json.loads(pr_summary_json)
    issues = []
    suggestions = []
    score = 100  # æ»¡åˆ†100ï¼Œæ‰£åˆ†åˆ¶
    
    # 1. æ£€æŸ¥åŸºæœ¬ PR ä¿¡æ¯
    if not pr_summary["title"] or len(pr_summary["title"]) < 10:
        issues.append("PR æ ‡é¢˜è¿‡äºç®€å•ï¼Œå»ºè®®æä¾›æ›´è¯¦ç»†çš„æè¿°")
        score -= 10
    
    if not pr_summary["body"] or len(pr_summary["body"]) < 50:
        issues.append("PR æè¿°è¿‡äºç®€å•ï¼Œå»ºè®®è¯¦ç»†è¯´æ˜å˜æ›´å†…å®¹å’ŒåŸå› ")
        score -= 10
    
    # 2. æ£€æŸ¥æ–‡ä»¶å˜æ›´
    if pr_summary["changed_files"] == 0:
        issues.append("PR æ²¡æœ‰æ–‡ä»¶å˜æ›´")
        score -= 20
    elif pr_summary["changed_files"] > 50:
        issues.append("PR å˜æ›´æ–‡ä»¶è¿‡å¤šï¼Œå»ºè®®æ‹†åˆ†ä¸ºå¤šä¸ªå°çš„ PR")
        score -= 15
    
    # 3. æ£€æŸ¥ä»£ç å˜æ›´é‡
    if pr_summary["additions"] + pr_summary["deletions"] > 2000:
        issues.append("ä»£ç å˜æ›´é‡è¾ƒå¤§ï¼Œå»ºè®®ä»”ç»†å®¡æŸ¥")
        score -= 10
    
    # 4. æ£€æŸ¥æ–‡ä»¶ç±»å‹å’Œå†…å®¹
    has_tests = False
    has_docs = False
    has_code = False
    
    for file_info in pr_summary["files"]:
        filename = file_info["filename"].lower()
        
        # æ£€æŸ¥æµ‹è¯•æ–‡ä»¶
        if "test" in filename or filename.endswith("_test.py") or filename.endswith("test.js"):
            has_tests = True
        
        # æ£€æŸ¥æ–‡æ¡£æ–‡ä»¶
        if filename.endswith((".md", ".rst", ".txt")) or "doc" in filename:
            has_docs = True
        
        # æ£€æŸ¥ä»£ç æ–‡ä»¶
        if filename.endswith((".py", ".js", ".ts", ".java", ".cpp", ".c", ".go", ".rs")):
            has_code = True
            
            # ç®€å•çš„ä»£ç è´¨é‡æ£€æŸ¥
            patch = file_info["patch"]
            if "TODO" in patch or "FIXME" in patch:
                issues.append(f"æ–‡ä»¶ {file_info['filename']} åŒ…å«æœªå®Œæˆçš„ TODO/FIXME")
                score -= 5
            
            if "print(" in patch and "test" not in filename:
                issues.append(f"æ–‡ä»¶ {file_info['filename']} å¯èƒ½åŒ…å«è°ƒè¯•ä»£ç ")
                score -= 3
    
    # 5. æ£€æŸ¥æµ‹è¯•è¦†ç›–
    if has_code and not has_tests:
        issues.append("ä»£ç å˜æ›´ç¼ºå°‘æµ‹è¯•ç”¨ä¾‹")
        score -= 15
        suggestions.append("æ·»åŠ ç›¸åº”çš„å•å…ƒæµ‹è¯•æˆ–é›†æˆæµ‹è¯•")
    
    # 6. æ£€æŸ¥æ–‡æ¡£æ›´æ–°
    if pr_summary["additions"] > 100 and not has_docs:
        issues.append("è¾ƒå¤§çš„å˜æ›´ç¼ºå°‘æ–‡æ¡£æ›´æ–°")
        score -= 10
        suggestions.append("æ›´æ–°ç›¸å…³æ–‡æ¡£è¯´æ˜å˜æ›´å†…å®¹")
    
    # 7. æ£€æŸ¥åˆå¹¶çŠ¶æ€
    if not pr_summary["mergeable"]:
        issues.append("PR å­˜åœ¨åˆå¹¶å†²çªæˆ–æ— æ³•è‡ªåŠ¨åˆå¹¶")
        score -= 20
    
    if pr_summary["mergeable_state"] == "dirty":
        issues.append("PR æœ‰åˆå¹¶å†²çª")
        score -= 25
    elif pr_summary["mergeable_state"] == "blocked":
        issues.append("PR è¢«é˜»æ­¢åˆå¹¶ï¼ˆå¯èƒ½éœ€è¦ CI æ£€æŸ¥æˆ–å®¡æŸ¥ï¼‰")
        score -= 15
    
    # 8. æ£€æŸ¥æ˜¯å¦ä¸ºè‡ªå·±çš„ PR
    if pr_summary["is_own_pr"]:
        issues.append("è¿™æ˜¯æ‚¨è‡ªå·±çš„ PRï¼Œéœ€è¦å…¶ä»–ç”¨æˆ·å®¡æŸ¥æ‰èƒ½åˆå¹¶")
        score -= 5  # ä¸æ‰£å¤ªå¤šåˆ†ï¼Œå› ä¸ºè¿™æ˜¯æ­£å¸¸æƒ…å†µ
    
    # ç”Ÿæˆå®¡æŸ¥æ€»ç»“
    summary_parts = []
    if score >= 80:
        summary_parts.append("âœ… ä»£ç è´¨é‡è‰¯å¥½")
    elif score >= 60:
        summary_parts.append("âš ï¸ ä»£ç è´¨é‡ä¸€èˆ¬ï¼Œæœ‰æ”¹è¿›ç©ºé—´")
    else:
        summary_parts.append("âŒ ä»£ç è´¨é‡éœ€è¦æ”¹è¿›")
    
    summary_parts.append(f"ğŸ“Š å®¡æŸ¥è¯„åˆ†: {score}/100")
    summary_parts.append(f"ğŸ“ å˜æ›´æ–‡ä»¶: {pr_summary['changed_files']} ä¸ª")
    summary_parts.append(f"ğŸ“ ä»£ç è¡Œæ•°: +{pr_summary['additions']} -{pr_summary['deletions']}")
    
    summary = "\n".join(summary_parts)
    
    # ç”Ÿæˆä¿®æ”¹å»ºè®®
    if not suggestions and issues:
        suggestions = ["è¯·æ ¹æ®ä¸Šè¿°é—®é¢˜è¿›è¡Œç›¸åº”ä¿®æ”¹"]
    
    # åšå‡ºå†³ç­–
    if score >= 80 and not pr_summary["is_own_pr"] and pr_summary["mergeable"]:
        decision = "approve_and_merge"
    elif score >= 60:
        if pr_summary["is_own_pr"] or pr_summary["commits"] > 10 or pr_summary["changed_files"] > 20:
            decision = "request_human_review"
        else:
            decision = "approve_and_merge"
    elif score >= 40:
        decision = "request_human_review"
    else:
        decision = "request_changes"
    
    return {
        "decision": decision,
        "score": score,
        "summary": summary,
        "issues": issues,
        "suggestions": suggestions,
        "details": {
            "has_tests": has_tests,
            "has_docs": has_docs,
            "has_code": has_code,
            "mergeable": pr_summary["mergeable"],
            "mergeable_state": pr_summary["mergeable_state"]
        }
    }


def selection_sort(arr: list[float]) -> list[float]:
    """
    ä½¿ç”¨é€‰æ‹©æ’åºç®—æ³•å¯¹æ•°å­—åˆ—è¡¨è¿›è¡Œæ’åºã€‚

    Args:
        arr: æ•°å­—åˆ—è¡¨ã€‚

    Returns:
        æ’åºåçš„æ–°åˆ—è¡¨ã€‚
    """
    if not isinstance(arr, list) or not all(isinstance(x, (int, float)) for x in arr):
        raise TypeError("è¾“å…¥å¿…é¡»æ˜¯æ•°å­—åˆ—è¡¨")

    sorted_arr = arr.copy()
    n = len(sorted_arr)
    for i in range(n):
        min_idx = i
        for j in range(i + 1, n):
            if sorted_arr[j] < sorted_arr[min_idx]:
                min_idx = j
        sorted_arr[i], sorted_arr[min_idx] = sorted_arr[min_idx], sorted_arr[i]
    return sorted_arr

def list_branches(repo_path: str, token_env: str = "GITHUB_TOKEN") -> dict:
    """
    è·å–æŒ‡å®šä»“åº“çš„åˆ†æ”¯åˆ—è¡¨

    Args:
        repo_path: ä»“åº“è·¯å¾„ï¼Œæ ¼å¼ä¸º "owner/repo"
        token_env: GitHub Token ç¯å¢ƒå˜é‡åï¼ˆé»˜è®¤ "GITHUB_TOKEN"ï¼‰

    Returns:
        dict: åŒ…å«åˆ†æ”¯åˆ—è¡¨æˆ–é”™è¯¯ä¿¡æ¯
    """
    try:
        token = os.getenv(token_env)
        g = Github(token) if token else Github()
        repo = g.get_repo(repo_path)
        branches = repo.get_branches()
        branch_list = [branch.name for branch in branches]
        return {
            "status": "success",
            "repo": repo_path,
            "branches": branch_list
        }
    except Exception as e:
        return {"error": f"è·å–åˆ†æ”¯åˆ—è¡¨å¤±è´¥: {str(e)}"}
